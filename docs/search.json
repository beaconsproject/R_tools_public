[
  {
    "objectID": "vignettes/createBuilderPolygons.html",
    "href": "vignettes/createBuilderPolygons.html",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction prep_input_column allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‚ÄòCATCHNUM‚Äô. prep_input_column needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‚ÄòBENCHMARKS‚Äô, ‚ÄòUPSTREAM‚Äô or ‚ÄòDOWNSTREAM‚Äô. Default is ‚ÄòBENCHMARKS‚Äô.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./R/createBuilderPolygons_dependencies.R\")\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data/catchments.shp\")\n\n#Set access path catchments layer and initialize\ncatchments_sf &lt;- st_read(catchments)\n\n# Name given to identify unique benchmark\ncolName &lt;- \"PB\"\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"benchmarks_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html#intro",
    "href": "vignettes/createBuilderPolygons.html#intro",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction prep_input_column allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‚ÄòCATCHNUM‚Äô. prep_input_column needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‚ÄòBENCHMARKS‚Äô, ‚ÄòUPSTREAM‚Äô or ‚ÄòDOWNSTREAM‚Äô. Default is ‚ÄòBENCHMARKS‚Äô.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./R/createBuilderPolygons_dependencies.R\")\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data/catchments.shp\")\n\n#Set access path catchments layer and initialize\ncatchments_sf &lt;- st_read(catchments)\n\n# Name given to identify unique benchmark\ncolName &lt;- \"PB\"\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"benchmarks_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/calcDCI.html",
    "href": "vignettes/calcDCI.html",
    "title": "Calculate dendritic connectivity index (DCI) on reserves",
    "section": "",
    "text": "This script calculates Dendritic Connectivity Index (DCI).\nThe first step is to locate the reserves (e.g., potential benchmarks, protected area) and stream network layers and point on an output directory where result layer will be saved.\nThe shapefiles must have the same CRS.\nFunction calc_dci calculate dendritic connectivity index (DCI) for a set of input polygons. Values range between 0 and 1, with 1 indicating a completely connected river network. Dendritic connectivity measures the longitudinal connectivity of a river network inside a set of reserves based on the expected probability of an organism being able to move between two random points in the network.\nFunction calc_lwdci calculate stream network length-weighted dendritic connectivity index (DCI) for a set of input polygons. Dendritic connectivity measures the longitudinal connectivity of a river network inside a set of conservation areas based on the expected probability of an organism being able to move between two random points in the network.\nBoth functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\nsource(\"./R/calcDCI_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/calcDCI.html#intro",
    "href": "vignettes/calcDCI.html#intro",
    "title": "Calculate dendritic connectivity index (DCI) on reserves",
    "section": "",
    "text": "This script calculates Dendritic Connectivity Index (DCI).\nThe first step is to locate the reserves (e.g., potential benchmarks, protected area) and stream network layers and point on an output directory where result layer will be saved.\nThe shapefiles must have the same CRS.\nFunction calc_dci calculate dendritic connectivity index (DCI) for a set of input polygons. Values range between 0 and 1, with 1 indicating a completely connected river network. Dendritic connectivity measures the longitudinal connectivity of a river network inside a set of reserves based on the expected probability of an organism being able to move between two random points in the network.\nFunction calc_lwdci calculate stream network length-weighted dendritic connectivity index (DCI) for a set of input polygons. Dendritic connectivity measures the longitudinal connectivity of a river network inside a set of conservation areas based on the expected probability of an organism being able to move between two random points in the network.\nBoth functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\nsource(\"./R/calcDCI_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "tools/seeds.html#usage",
    "href": "tools/seeds.html#usage",
    "title": "seeds()",
    "section": "Usage",
    "text": "Usage\nseeds(\n  catchments_sf,\n  filter_polygon = NULL,\n  areatarget_value = NULL,\n  areatarget_col = NULL,\n  areatarget_polygon = NULL,\n  areatarget_polygon_col = NULL\n)"
  },
  {
    "objectID": "tools/seeds.html#arguments",
    "href": "tools/seeds.html#arguments",
    "title": "seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nfilter_polygon: (Optional) sf polygon to filter catchments. Only catchments inside the polygon are kept.\nareatarget_value: (Optional) Single area target value (in m¬≤) to apply to all seeds.\nareatarget_col: (Optional) Column in catchments_sf containing individual area targets.\nareatarget_polygon: (Optional) sf polygon object holding area target values, used via spatial join.\nareatarget_polygon_col: (Optional) Column in areatarget_polygon containing area target values."
  },
  {
    "objectID": "tools/seeds.html#output",
    "href": "tools/seeds.html#output",
    "title": "seeds()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of seed catchments and their assigned area targets."
  },
  {
    "objectID": "tools/seeds.html#details",
    "href": "tools/seeds.html#details",
    "title": "seeds()",
    "section": "Details",
    "text": "Details\n\nFiltering\nIf no filter is provided, all catchments in catchments_sf will be added to the seeds table.\n\nTo filter using a column, use dplyr::filter() before passing catchments_sf to seeds().\nIf filter_polygon is used, filtering is based on whether the centroid (using sf::st_point_on_surface()) falls inside the polygon.\n\n\n\nArea Targets\nArea targets must be in square meters (m¬≤). Provide one of the following (priority is top to bottom):\n\nSingle value: areatarget_value applies to all seeds.\nColumn-based: Values from areatarget_col in catchments_sf.\nSpatial join: Join with areatarget_polygon; values from areatarget_polygon_col.¬†When multiple polygons overlap a catchment, the value with the most overlap is used."
  },
  {
    "objectID": "tools/seeds.html#examples",
    "href": "tools/seeds.html#examples",
    "title": "seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nDownload the functions, data and example files and save them in the proper folder.\n\n\nDownload builder functions in the R folder\nDownload catchments sample in the data folder\nDownload seeds example R script\n\n\nIn R, either:\n\nPlace the files in your working directory (getwd()), or\nUpdate the path in the examples using a data_path variable.\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nseeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\n\n# Use column-based area targets\ncatchments_sample$area_target &lt;- 1000000000\nseeds(catchments_sf = catchments_sample, areatarget_col = \"area_target\")\n\n# Filter based on a column value\ncatchments_sample %&gt;%\n  filter(intact == 1) %&gt;%\n  seeds(catchments_sf = ., areatarget_value = 1000000000)\n\n# Filter using a spatial polygon\nref_poly &lt;- data.frame(\n  lon = c(-138.4, -138.1, -138.1, -138.4, -138.1, -138.1, -138, -138),\n  lat = c(64.3, 64.3, 64.1, 64.1, 64.3, 64.1, 64.1, 64.3),\n  Areatarget = c(rep(1000000000, 4), rep(2000000000, 4))\n) %&gt;%\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %&gt;%\n  group_by(Areatarget) %&gt;%\n  summarise(geometry = st_combine(geometry)) %&gt;%\n  st_cast(\"POLYGON\") %&gt;%\n  st_transform(st_crs(catchments_sample))\n\nseeds(\n  catchments_sf = catchments_sample,\n  filter_polygon = ref_poly,\n  areatarget_polygon = ref_poly,\n  areatarget_polygon_col = \"Areatarget\"\n)\n\n# save seeds as csv\nseed &lt;- seeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\nwrite.csv(seed, file=file.path(dirpath,\"Builder_input/seeds.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/neighbours.html#usage",
    "href": "tools/neighbours.html#usage",
    "title": "neighbours()",
    "section": "Usage",
    "text": "Usage\nneighbours(\n  catchments_sf\n)"
  },
  {
    "objectID": "tools/neighbours.html#arguments",
    "href": "tools/neighbours.html#arguments",
    "title": "neighbours()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM."
  },
  {
    "objectID": "tools/neighbours.html#output",
    "href": "tools/neighbours.html#output",
    "title": "neighbours()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of neighbouring pairs with columns CATCHNUM and neighbours."
  },
  {
    "objectID": "tools/neighbours.html#examples",
    "href": "tools/neighbours.html#examples",
    "title": "neighbours()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nDownload the functions, data and example files and save them in the proper folder.\n\n\nDownload builder functions in the R folder\nDownload catchments sample in the data folder\nDownload neighbours example R script\n\n\nIn R, either:\n\nPlace the files in your working directory (getwd()), or\nUpdate the path in the examples using a data_path variable.\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nneighbours(catchments_sf = catchments_sample)\n\n# save neighbours as csv\nneighbour &lt;- neighbours(catchments_sf = catchments_sample)\nwrite.csv(neighbour, file=file.path(dirpath,\"Builder_input/neighbours.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/builder.html#usage",
    "href": "tools/builder.html#usage",
    "title": "builder()",
    "section": "Usage",
    "text": "Usage\nbuilder(\n  catchments_sf, \n  seeds, \n  neighbours, \n  out_dir = NULL,\n  builder_local_path, \n  catchment_level_intactness = 1, \n  conservation_area_intactness = 1, \n  area_target_proportion = 1, \n  area_type = \"land\", \n  construct_conservation_areas = TRUE,  \n  area_target_multiplier = 1,\n  handle_isolated_catchments = TRUE, \n  output_upstream = FALSE, \n  output_downstream = FALSE, \n  output_hydrology_metrics = FALSE,\n  area_land = \"Area_Land\", \n  area_water = \"Area_Water\",\n  skeluid = \"SKELUID\", \n  catchnum = \"CATCHNUM\", \n  subzone = \"FDA\", \n  zone = \"MDA\", \n  basin = \"BASIN\", \n  order1 = \"ORDER1\",\n  order2 = \"ORDER2\", \n  order3 = \"ORDER3\", \n  stream_length = \"STRMLEN\", \n  intactness = \"intact\", \n  isolated = \"Isolated\",\n  unique_identifier = \"PB\", \n  handler_summary = FALSE, \n  summary_intactness_props = '\"\"', \n  summary_area_target_props = '\"\"'\n)"
  },
  {
    "objectID": "tools/builder.html#arguments",
    "href": "tools/builder.html#arguments",
    "title": "builder()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with unique identifier column CATCHNUM.\nseeds: Seeds table from seeds() listing seed catchments and area targets.\nneighbours: Neighbours table from neighbours() listing all neighbouring pairs of catchments.\nout_dir: If provided, input (seeds, neighbours and catchments) files and output BUILDER tables will be saved to this directory. Otherwise a temp directory will be used. Function will attempt to create the directory if it doesn‚Äôt already exist.\nbuilder_local_path: Directory path to the benchmarkbuilder executable.\ncatchment_level_intactness: Minimum intactness value for catchment inclusion (between 0-1). i.e.¬†if value of 1 is used, only 100% intact catchments will be used.\nconservation_area_intactness: Minimum area-weighted intactness of final conservation areas. Only conservation areas meeting this value will be returned.\narea_target_proportion: The proportion of the Area target that conservation areas need to meet (0-1) to be returned by the function.\narea_type: If ‚Äòland‚Äô, only terrestrial areas are counted towards the area target. If ‚Äòwater‚Äô, only water areas are counter. If ‚Äòlandwater‚Äô, all areas are counted.\nconstruct_conservation_areas: Should builder build conservation areas?\narea_target_multiplier: Multiplier applied to the area target in the seed list that allows for adjustments to the area target without having to remake the seeds table.\nhandle_isolated_catchments: Should small isolated catchments be merged into the conservation areas?\noutput_upstream: Should upstream catchments be calculated?\noutput_downstream: Should downstream catchments be calculated?\noutput_hydrology_metrics: Should hydrology metrics be calculated?\narea_land: Catchments column listing the area of land in each catchment.\narea_water: Catchments column listing the area of water in each catchment.\nskeluid: Catchments column listing the skeluid field.\ncatchnum: Catchments column listing the unique catchments ID.\nsubzone: Catchments column listing the hydrological subzone.\nzone: Catchments column listing the hydrological zone.\nbasin: Catchments column listing the basin field.\norder1: Catchments column listing the order 1 field.\norder2: Catchments column listing the order 2 field.\norder3: Catchments column listing the order 3 field.\nstream_length: Catchments column listing stream length.\nintactness: Catchments column listing the intactness value.\nisolated: Catchments column identifying catchments isolated from the stream network.\nunique_identifier: Prefix for conservation area names.\nhandler_summary: Should a summary listing counts of available conservation areas at different intactness and area target proportions be created?\nsummary_intactness_props: If a summary is created, provide the intactness proportions to be summarised in the format ‚Äò0.7,0.8,0.9‚Äô.\nsummary_area_target_props: If a summary is created, provide the area target proportions to be summarised in the format ‚Äò0.7,0.8,0.9‚Äô."
  },
  {
    "objectID": "tools/builder.html#output",
    "href": "tools/builder.html#output",
    "title": "builder()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble with column names representing conservation areas, and rows of catchments making up the conservation areas. If output_dir is provided, additional BUILDER output tables (e.g., hydrology, summary metrics) are saved."
  },
  {
    "objectID": "tools/builder.html#details",
    "href": "tools/builder.html#details",
    "title": "builder()",
    "section": "Details",
    "text": "Details\nThis function prepares the input tables (neighbours, seeds, catchments) required by BUILDER in a temp file, then creates a string of parameters that is passed to the BUILDER executable using system(). The BUILDER output tables are saved to the temp file, and the output table listing conservation area names and catchment lists is returned to the R session.\nThis function only returns the BUILDER output table describing the lists of catchments making up each conservation area. We typically recommend using the beaconstools package to calculate hydrology metrics, but hydrology information as well as other summary information is produced by BUILDER. If users want access to the complete set of BUILDER output tables (e.g.¬†hydrology and summary information), a valid output directory can be provided in which case all input and output tables will be saved to that directory. If no output directory is provided a temp folder will be used and deleted after the function completes. As well as providing access to the full list of BUILDER output tables, an output directory is useful in a looped workflow with multiple calls to BUILDER producing multiple sets of output files. In this workflow a different output directory can be used to save each set of output files which can later be processed using the beaconstools package. The main output file listing conservation area names and their catchments is named ‚Äú*_COLUMN_All_Unique_BAs.csv‚Äù.\nThe main parameters to adjust when building conservation areas are:\n\nArea target: Set in the seeds table, this defines the minimum size for each conservation area.\nCatchment-level intactness: Only catchments with intactness values greater than this value will be added to the conservation area.\nConservation area intactness: Only conservation areas with an area-weighted intactness greater than or equal to this value will be returned.\nArea-target proportion: The proportion of the Area target that conservation areas need to meet. Allows output of conservation areas smaller than the area target (e.g.¬†if no conservation areas meet 100% of the area target, area target multiplier can be lowered to 0.9 to search for smaller conservation areas)."
  },
  {
    "objectID": "tools/builder.html#examples",
    "href": "tools/builder.html#examples",
    "title": "builder()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_output\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nDownload the functions, data and example files and save them in the proper folder.\n\n\nDownload builder functions in the R folder\nDownload utils functions in the R folder\nDownload catchments sample in the data folder\nDownload builder example R script\n\n\nIn R, either:\n\nPlace the files in your working directory (getwd()), or\nUpdate the path in the examples using a data_path variable.\n\nRun the examples below.\n\nlibrary(sf)\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\n\nnghbrs &lt;- neighbours(catchments_sample)\nseed &lt;- seeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\nbuilder(catchments_sf = catchments_sample, seeds = seed, neighbours = nghbrs, out_dir = file.path(dirpath, \"Builder_output\"), builder_local_path = dirpath)"
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Workflow",
    "section": "",
    "text": "clickable flowchart"
  },
  {
    "objectID": "methods.html#step-1",
    "href": "methods.html#step-1",
    "title": "Workflow",
    "section": "Step 1",
    "text": "Step 1"
  },
  {
    "objectID": "methods.html#step-2",
    "href": "methods.html#step-2",
    "title": "Workflow",
    "section": "Step 2",
    "text": "Step 2"
  },
  {
    "objectID": "methods.html#step-3",
    "href": "methods.html#step-3",
    "title": "Workflow",
    "section": "Step 3",
    "text": "Step 3"
  },
  {
    "objectID": "methods.html#step-4",
    "href": "methods.html#step-4",
    "title": "Workflow",
    "section": "Step 4",
    "text": "Step 4"
  },
  {
    "objectID": "methods.html#step-5",
    "href": "methods.html#step-5",
    "title": "Workflow",
    "section": "Step 5",
    "text": "Step 5"
  },
  {
    "objectID": "methods.html#step-6",
    "href": "methods.html#step-6",
    "title": "Workflow",
    "section": "Step 6",
    "text": "Step 6"
  },
  {
    "objectID": "methods.html#step-7",
    "href": "methods.html#step-7",
    "title": "Workflow",
    "section": "Step 7",
    "text": "Step 7"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Welcome to the BEACONs R tools pages!\nOver the years, BEACONs develops a series of function to ease conservation planning across the landscape. Those functions have been group into categories. This pages aims to document each function and demonstrate their use through example. The functions are target advanced users who work with environmental data at large scale."
  },
  {
    "objectID": "report-issues.html",
    "href": "report-issues.html",
    "title": "Reporting an Issue",
    "section": "",
    "text": "Reporting an Issue\nIf you‚Äôve found a bug or something isn‚Äôt working as expected, please follow the instructions below before reporting:\n\nClick the button below to go to our GitHub issues page and submit your bug report.\nClick the green button üêõ New Issue to open an issue.\nClearly describe the issue. Mention the function name(s) involved.\nProvide a minimal reproducible example, if possible.\nInclude error messages or screenshots if available.\n\nClick the button below to go to our GitHub issues page and submit your bug report.\n\n üö® Report an Issue on GitHub"
  },
  {
    "objectID": "tools/Builder_index.html",
    "href": "tools/Builder_index.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Download BUILDER functions"
  },
  {
    "objectID": "tools/Builder_index.html#beacons-builder",
    "href": "tools/Builder_index.html#beacons-builder",
    "title": "BEACONs R Tools",
    "section": "BEACONs BUILDER",
    "text": "BEACONs BUILDER\nBUILDER is a user friendly software application, developed in C# .NET framework, to assist conservation planners with the design of ecological benchmarks. This package provides a set of R functions to call BUILDER and fetch the main output table. The partner package beaconstools provides functions to process and analyse output tables from BUILDER in R.\nBUILDER explicitly incorporates hydrologic connectivity for the integration of aquatic and terrestrial conservation planning in protected areas design. BUILDER constructs ecological benchmarks using a deterministic construction algorithm that aggregates catchments to a user defined size and intactness. For the purpose of this demo, we will refer to the conservation areas created by BUILDER as benchmarks, however BUILDER can also be used to design conservation areas not intended to serve as benchmarks.\nBUILDER constructs ecological benchmarks based on three principal criteria:\n\nIntactness, a measure of the absence of human industrial activity and a proxy for the intactness of biological and physical processes\nHydrologic connectivity of intact water catchments, as a measure of the integrity of aquatic systems\nSize, as a measure of the resilience of the system to disturbance"
  },
  {
    "objectID": "tools/Builder_index.html#catchments",
    "href": "tools/Builder_index.html#catchments",
    "title": "BEACONs R Tools",
    "section": "Catchments",
    "text": "Catchments\nThe building blocks for BUILDER is a set of catchments with associated flow directions for the underlying stream network. This allows BUILDER to identify upstream and downstream catchments for any given location. Should we provide a brief description of the catchments dataset and how to download them?"
  },
  {
    "objectID": "tools/Builder_index.html#aggregation-algorithm",
    "href": "tools/Builder_index.html#aggregation-algorithm",
    "title": "BEACONs R Tools",
    "section": "Aggregation algorithm",
    "text": "Aggregation algorithm\nBUILDER ‚Äògrows‚Äô ecological benchmarks using a deterministic construction algorithm that aggregates catchments. This process enables intactness, size and hydrologic criteria to be incorporated into benchmark design.\nThe starting catchments for building benchmarks are called seeds. These can be selected using size and intactness criteria e.g., all catchments that are 100% intact and greater than 500km2. Starting from a seed, BUILDER grows a benchmark by aggregating neighbouring catchments that exceed the user defined catchment-level intactness threshold. As catchments are added, growth is prioritized in the upstream direction. This emphasizes inclusion of headwaters within benchmarks, and encourages the formation of benchmarks along stream networks. Further, by adding all eligible upstream catchments before re-querying for more, benchmarks are grown with a more compact shape. If re-querying were to occur after adding each upstream catchment, benchmarks would tend to grow along single streams, resulting in linear configurations. To further compact the shape of the benchmark, BUILDER prioritizes the addition of catchments within hydrological zones (i.e.¬†Fundamental Drainage Areas, FDAs) associated with the benchmark before adding catchments in a neighbouring FDA.\nOnce all available upstream catchments are added, BUILDER grows downstream. Downstream growth adds all neighbouring catchments downstream of the catchment aggregation then re-queries for upstream catchments. Benchmarks are grown until:\n\nThere are no more neighbouring, intact catchments to add, or\nThe benchmarks area exceeds the user-specified Area Target.\n\nIf the latter occurs, and the area-weighted intactness of the benchmark exceeds the benchmark-level intactness threshold, then the benchmark is included in the output."
  },
  {
    "objectID": "tools/Builder_index.html#builder-r-functions",
    "href": "tools/Builder_index.html#builder-r-functions",
    "title": "BEACONs R Tools",
    "section": "BUILDER R Functions",
    "text": "BUILDER R Functions\nBEACONs BUILDER has 4 main functions:\n\nseeds\nreserve_seeds\nneighbours\nbuilder\n\n\nseeds\nThe function seeds() creates a seeds table, which is an input to builder().\nIt identifies seed catchments and assigns them an area target.\n\n\nreserve_seeds\nThe function reserve_seeds() creates a seeds table based on conservation areas, which is an input to builder().\nIt identifies seed catchments inside a conservation area and assigns them an area target.\n\n\nneighbours\nThe function neighbours() creates a table listing pairwise catchment neighbours. Used as an input to builder().\n\n\nbuilder\nThe function builder() prepares the input files and parameters and passes them to a command line version of BUILDER executable software that resides inside the benchmarkbuilder package. The function then fetches and returns the main BUILDER output table into the R environment. Should we put something about how to obtain the executable and where to place it?\nUltimately we hope to rewrite the BUILDER executable in R to avoid having to call a third party application. In the meantime, this package allows users to access and automate calls to BUILDER from R."
  },
  {
    "objectID": "tools/Builder_index.html#process",
    "href": "tools/Builder_index.html#process",
    "title": "BEACONs R Tools",
    "section": "üèóÔ∏è Process",
    "text": "üèóÔ∏è Process\n\nPrepares input tables: neighbours, seeds, and catchments.\nWrites files to a temp directory (or output_dir if provided).\nConstructs a command to run BUILDER via system().\nbuilder() returns the *_COLUMN_All_Unique_BAs.csv file listing conservation areas and their catchments.\nSubsequent processing, such as creating polygons of benchmarks using builder() output and assessing ecological attributes is done using others BEACONs functions (see examples in section Articles)."
  },
  {
    "objectID": "tools/Builder_index.html#key-parameters",
    "href": "tools/Builder_index.html#key-parameters",
    "title": "BEACONs R Tools",
    "section": "üîß Key Parameters",
    "text": "üîß Key Parameters\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nArea target\nSet in the seeds table; minimum size (m¬≤) for each conservation area.\n\n\nCatchment intactness\nMinimum intactness required for catchments to be included.\n\n\nConservation area intactness\nMinimum area-weighted intactness for a conservation area to be returned.\n\n\nArea target proportion\nAllows output of smaller areas (e.g., 0.9 returns areas &gt;= 90% of the area target)."
  },
  {
    "objectID": "tools/Builder_index.html#tip",
    "href": "tools/Builder_index.html#tip",
    "title": "BEACONs R Tools",
    "section": "üí° Tip",
    "text": "üí° Tip\nUse output_dir to preserve BUILDER‚Äôs complete outputs when running multiple builds. These files can be further analyzed using others BEACONs functions."
  },
  {
    "objectID": "tools/Builder_index.html#citation",
    "href": "tools/Builder_index.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nPlease cite the beaconsbuilder package when using it in publications. To cite the latest official version, please use:\nEdwards M, Vernier P, Lisgo K, Houle M, Schmiegelow F (2022). beaconsbuilder: building conservation areas in R. R package version 0.0.0.9000. Available at https://github.com/beaconsproject/beaconsbuilder."
  },
  {
    "objectID": "tools/reserve_seeds.html#usage",
    "href": "tools/reserve_seeds.html#usage",
    "title": "reserve_seeds()",
    "section": "Usage",
    "text": "Usage\nreserve_seeds(\n  catchments_sf,\n  CAs_sf,\n  CAs_name = NULL,\n  areatarget_value = NULL,\n  joinType = NULL\n)"
  },
  {
    "objectID": "tools/reserve_seeds.html#arguments",
    "href": "tools/reserve_seeds.html#arguments",
    "title": "reserve_seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nCAs_sf: A character string. Name of the column holding conservation area unique identifiers.\nCAs_name: A character string. Name of the column holding conservation area unique identifiers.\nareatarget_value: (Optional) A single numeric value specifying the area target to apply to all seeds.\njoinType: A character string. Type of spatial join to identify catchments within conservation areas. Options are \"INTERSECT\" or \"CENTROID\". Default is \"CENTROID\"."
  },
  {
    "objectID": "tools/reserve_seeds.html#output",
    "href": "tools/reserve_seeds.html#output",
    "title": "reserve_seeds()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of reserve seed catchments and their associated area targets."
  },
  {
    "objectID": "tools/reserve_seeds.html#examples",
    "href": "tools/reserve_seeds.html#examples",
    "title": "reserve_seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nDownload the functions, data and example files and save them in the proper folder.\n\n\nDownload builder functions in the R folder\nDownload catchments sample in the data folder\nDownload reserves sample in the data folder\nDownload reserve_seeds example R script\n\n\nIn R, either:\n\nPlace the files in your working directory (getwd()), or\nUpdate the path in the examples using a data_path variable.\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nreserves_sample &lt;- readRDS(\"data/reserves_sample.rds\")\nreserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_name = \"reserve\", areatarget_value = 1000000000)\n\n# save seeds as csv\nreserve_seed &lt;- reserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_name = \"reserve\", areatarget_value = 1000000000)\nwrite.csv(reserve_seed, file=file.path(dirpath,\"Builder_input/reserve_seeds.csv\"), na = \"\", row.names=FALSE)"
  },
  {
    "objectID": "tools/Spatial_index.html",
    "href": "tools/Spatial_index.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Spatial"
  },
  {
    "objectID": "vignettes/createBuilderInput.html",
    "href": "vignettes/createBuilderInput.html",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‚ÄòCATCHNUM‚Äô.\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\npas &lt;- file.path(dirpath, \"data\", \"reserves_sample.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderInput.html#intro",
    "href": "vignettes/createBuilderInput.html#intro",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‚ÄòCATCHNUM‚Äô.\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\npas &lt;- file.path(dirpath, \"data\", \"reserves_sample.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  }
]