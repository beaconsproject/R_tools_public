[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Welcome to the BEACONs R tools pages!\nOver the years, BEACONs develops a series of function to ease conservation planning across the landscape. Those functions have been group into categories. This pages aims to document each function and demonstrate their use through example. The functions are target advanced users who work with environmental data at large scale."
  },
  {
    "objectID": "tools/Builder.html",
    "href": "tools/Builder.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs Builder allows you to build conservation areas following rules of size, intactness, and hydrological connectivity. You can visit the package website here: https://beaconsproject.github.io/beaconsbuilder.\nbeaconsbuilder should be used together with the beaconstools package to construct and analyse sets of conservation areas. More details on how beaconsbuilder works can be found in vignette(“builder”).\nBEACONs Builder has 4 main functions:\n\nseeds\nreserve_seeds\nneighbours\nbuilder\n\n\n\nThe seeds() function creates a seeds table, which is an input to builder().\nIt identifies seed catchments and assigns them an area target.\n\n\nIf no filter arguments are used, all catchments in catchments_sf are included.\nOptions: - Use dplyr::filter() to pre-filter. - Use filter_polygon to keep only catchments whose centroid lies inside the polygon.\n\n\n\nArea targets (in m²) can be provided using one of the following (priority order):\n\nareatarget_value: a single fixed target for all seeds\n\nareatarget_col: column from catchments_sf\n\nareatarget_polygon + areatarget_polygon_col: spatial join, most overlapping polygon used\n\n\n\n\n\n\n\n\nCreate a neighbours table listing neighbours for each catchment.\nFor an sf object of catchments with unique CATCHNUM id’s, calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\n\n\n\nThe builder() function calls the BUILDER software from R. It prepares inputs, runs the external executable, and returns the main output table.\n\n\n\nPrepares input tables: neighbours, seeds, and catchments.\nWrites files to a temp directory (or output_dir if provided).\nConstructs a command to run BUILDER via system().\nReturns the *_COLUMN_All_Unique_BAs.csv file listing conservation areas and their catchments.\n\n\n\n\n\nReturns a tibble of conservation area names and associated catchments.\nIf output_dir is provided, additional BUILDER output tables (e.g., hydrology, summary metrics) are saved.\n\n\n\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nArea target\nSet in the seeds table; minimum size (m²) for each conservation area.\n\n\nCatchment intactness\nMinimum intactness required for catchments to be included.\n\n\nConservation area intactness\nMinimum area-weighted intactness for a conservation area to be returned.\n\n\nArea target proportion\nAllows output of smaller areas (e.g., 0.9 returns areas &gt;= 90% of the area target).\n\n\n\n\n\n\nUse output_dir to preserve BUILDER’s complete outputs when running multiple builds. These files can be further analyzed using beaconstools.\n \n##Citation Please cite the beaconsbuilder package when using it in publications. To cite the latest official version, please use:\nEdwards M, Vernier P, Lisgo K, Houle M, Schmiegelow F (2022). beaconsbuilder: building conservation areas in R. R package version 0.0.0.9000. Available at https://github.com/beaconsproject/beaconsbuilder."
  },
  {
    "objectID": "tools/Builder.html#beacons-builder",
    "href": "tools/Builder.html#beacons-builder",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs Builder allows you to build conservation areas following rules of size, intactness, and hydrological connectivity. You can visit the package website here: https://beaconsproject.github.io/beaconsbuilder.\nbeaconsbuilder should be used together with the beaconstools package to construct and analyse sets of conservation areas. More details on how beaconsbuilder works can be found in vignette(“builder”).\nBEACONs Builder has 4 main functions:\n\nseeds\nreserve_seeds\nneighbours\nbuilder\n\n\n\nThe seeds() function creates a seeds table, which is an input to builder().\nIt identifies seed catchments and assigns them an area target.\n\n\nIf no filter arguments are used, all catchments in catchments_sf are included.\nOptions: - Use dplyr::filter() to pre-filter. - Use filter_polygon to keep only catchments whose centroid lies inside the polygon.\n\n\n\nArea targets (in m²) can be provided using one of the following (priority order):\n\nareatarget_value: a single fixed target for all seeds\n\nareatarget_col: column from catchments_sf\n\nareatarget_polygon + areatarget_polygon_col: spatial join, most overlapping polygon used\n\n\n\n\n\n\n\n\nCreate a neighbours table listing neighbours for each catchment.\nFor an sf object of catchments with unique CATCHNUM id’s, calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\n\n\n\nThe builder() function calls the BUILDER software from R. It prepares inputs, runs the external executable, and returns the main output table.\n\n\n\nPrepares input tables: neighbours, seeds, and catchments.\nWrites files to a temp directory (or output_dir if provided).\nConstructs a command to run BUILDER via system().\nReturns the *_COLUMN_All_Unique_BAs.csv file listing conservation areas and their catchments.\n\n\n\n\n\nReturns a tibble of conservation area names and associated catchments.\nIf output_dir is provided, additional BUILDER output tables (e.g., hydrology, summary metrics) are saved.\n\n\n\n\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nArea target\nSet in the seeds table; minimum size (m²) for each conservation area.\n\n\nCatchment intactness\nMinimum intactness required for catchments to be included.\n\n\nConservation area intactness\nMinimum area-weighted intactness for a conservation area to be returned.\n\n\nArea target proportion\nAllows output of smaller areas (e.g., 0.9 returns areas &gt;= 90% of the area target).\n\n\n\n\n\n\nUse output_dir to preserve BUILDER’s complete outputs when running multiple builds. These files can be further analyzed using beaconstools.\n \n##Citation Please cite the beaconsbuilder package when using it in publications. To cite the latest official version, please use:\nEdwards M, Vernier P, Lisgo K, Houle M, Schmiegelow F (2022). beaconsbuilder: building conservation areas in R. R package version 0.0.0.9000. Available at https://github.com/beaconsproject/beaconsbuilder."
  },
  {
    "objectID": "vignettes/createBuilderInput.html",
    "href": "vignettes/createBuilderInput.html",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments shapefiles and point on an output directory where the derived files will be saved. The script uses two functions from the beaconsbuilder package: seeds and neighbour.\nThe neighbours function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nBoth functions need the catchments dataset with unique identifier column ‘CATCHNUM’\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(out_dir,\"nghbrs.csv\"), row.names=FALSE) \n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(out_dir, \"seeds.csv\"), row.names=FALSE) # Convert neighbours table to csv file.\n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\npas &lt;- file.path(dirpath, \"data\", \"PAs_MDA06.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nseed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\", out_dir = file.path(dirpath, \"Builder_input\"))\n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\npas &lt;- file.path(dirpath, \"data\", \"PAs_MDA06.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(out_dir, \"catchments.csv\"), row.names=FALSE) # Convert neighbours table to csv file."
  },
  {
    "objectID": "vignettes/createBuilderInput.html#intro",
    "href": "vignettes/createBuilderInput.html#intro",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments shapefiles and point on an output directory where the derived files will be saved. The script uses two functions from the beaconsbuilder package: seeds and neighbour.\nThe neighbours function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nBoth functions need the catchments dataset with unique identifier column ‘CATCHNUM’\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(out_dir,\"nghbrs.csv\"), row.names=FALSE) \n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(out_dir, \"seeds.csv\"), row.names=FALSE) # Convert neighbours table to csv file.\n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\npas &lt;- file.path(dirpath, \"data\", \"PAs_MDA06.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nseed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\", out_dir = file.path(dirpath, \"Builder_input\"))\n\n\n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/createBuilderInput\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"Builder_input\")\nfor(d in out_dir){\n  if(!dir.exists(file.path(out_dir))){\n    dir.create(file.path(out_dir))\n  }\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catch1M_KBA_MDA06.shp\")\npas &lt;- file.path(dirpath, \"data\", \"PAs_MDA06.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(out_dir, \"catchments.csv\"), row.names=FALSE) # Convert neighbours table to csv file."
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html",
    "href": "vignettes/createBuilderPolygons.html",
    "title": "create Builder Polygons",
    "section": "",
    "text": "This script generates potential benchmarks, upstream and downstream polygon based on the builder output.\nThe first step is to locate catchments and protected areas shapefile representing the reserves and point on an output directory where all derived files will be saved. Catchments and protected areas shapefile must be using the same CRS.\n\n# Load libraries\nlibrary(sf)\n\nLinking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(utils)\nsource(\"./createBuilderPolygons_dependencies.R\")\n\n\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/preBuilder\"\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\noutDir &lt;- file.path(dirpath, \"shp_output\")\n\n#Set access path catchments layer and initialize\ncatchments &lt;- file.path(dirpath ,\"NCC_Quebec/debug_files_2025-03-19/input\", \"QC_catch.shp\")\ncatchments_sf &lt;- st_read(catchments)\n\nReading layer `QC_catch' from data source \n  `E:\\MelinaStuff\\BEACONs\\request\\Kim\\preBuilder\\NCC_Quebec\\debug_files_2025-03-19\\input\\QC_catch.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 248828 features and 19 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 763371.1 ymin: -1650115 xmax: 1611156 ymax: -474158.4\nProjected CRS: NAD_1983_Albers\n\nstreams &lt;- file.path(dirpath ,\"NCC_Quebec/debug_files_2025-03-19/input\", \"streams.shp\")\nstreams_sf &lt;- st_read(streams)\n\nReading layer `streams' from data source \n  `E:\\MelinaStuff\\BEACONs\\request\\Kim\\preBuilder\\NCC_Quebec\\debug_files_2025-03-19\\input\\streams.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 32763 features and 36 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 777035 ymin: -1646310 xmax: 1605693 ymax: -480470.6\nProjected CRS: NAD_1983_Albers\n\n# Name given to identify unique benchmark\ncolName &lt;- \"network\"\n\n# Calculate hydrology metrics\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE"
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html#intro",
    "href": "vignettes/createBuilderPolygons.html#intro",
    "title": "create Builder Polygons",
    "section": "",
    "text": "This script generates potential benchmarks, upstream and downstream polygon based on the builder output.\nThe first step is to locate catchments and protected areas shapefile representing the reserves and point on an output directory where all derived files will be saved. Catchments and protected areas shapefile must be using the same CRS.\n\n# Load libraries\nlibrary(sf)\n\nLinking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(utils)\nsource(\"./createBuilderPolygons_dependencies.R\")\n\n\n#Set access path \ndirpath &lt;- \"E:/MelinaStuff/BEACONs/request/Kim/preBuilder\"\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\noutDir &lt;- file.path(dirpath, \"shp_output\")\n\n#Set access path catchments layer and initialize\ncatchments &lt;- file.path(dirpath ,\"NCC_Quebec/debug_files_2025-03-19/input\", \"QC_catch.shp\")\ncatchments_sf &lt;- st_read(catchments)\n\nReading layer `QC_catch' from data source \n  `E:\\MelinaStuff\\BEACONs\\request\\Kim\\preBuilder\\NCC_Quebec\\debug_files_2025-03-19\\input\\QC_catch.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 248828 features and 19 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 763371.1 ymin: -1650115 xmax: 1611156 ymax: -474158.4\nProjected CRS: NAD_1983_Albers\n\nstreams &lt;- file.path(dirpath ,\"NCC_Quebec/debug_files_2025-03-19/input\", \"streams.shp\")\nstreams_sf &lt;- st_read(streams)\n\nReading layer `streams' from data source \n  `E:\\MelinaStuff\\BEACONs\\request\\Kim\\preBuilder\\NCC_Quebec\\debug_files_2025-03-19\\input\\streams.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 32763 features and 36 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 777035 ymin: -1646310 xmax: 1605693 ymax: -480470.6\nProjected CRS: NAD_1983_Albers\n\n# Name given to identify unique benchmark\ncolName &lt;- \"network\"\n\n# Calculate hydrology metrics\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE"
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html#generate-potential-benchmarks-upstream-and-downstream-polygons-from-catchments-using-builder-output-files",
    "href": "vignettes/createBuilderPolygons.html#generate-potential-benchmarks-upstream-and-downstream-polygons-from-catchments-using-builder-output-files",
    "title": "create Builder Polygons",
    "section": "1. Generate potential benchmarks, upstream and downstream polygons from catchments using Builder output files",
    "text": "1. Generate potential benchmarks, upstream and downstream polygons from catchments using Builder output files\nFunction prep_input_column allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‘CATCHNUM’. prep_input_column needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. type can be ‘BENCHMARKS’, ‘UPSTREAM’ or ‘DOWNSTREAM’. Default is ‘BENCHMARKS’.\n\n\n#############################################\n#  Generate benchmark polygons\n#############################################\nout_tab &lt;- prep_input_column(builder_dir)\n\nReturning BUILDER table: 2025_04_15_1201_ROW_BLIT_i80_t80_COLUMN_All_Unique_BAs.csv\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nif(addDCI){\n  poly_sf &lt;- poly_sf %&gt;%\n  mutate(dci = sapply(1:nrow(poly_sf), function(i) {\n    i &lt;- poly_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  poly_sf &lt;- poly_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(poly_sf), function(j) {\n    j &lt;- poly_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n\nwrite_sf(poly_sf, dsn =file.path(outDir, \"benchmarks_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate upstream polygons\n#############################################\nout_tab &lt;- prep_input_column(builder_dir, \"UPSTREAM\")\n\nReturning BUILDER table: 2025_04_15_1201_ROW_BLIT_i80_t80_UPSTREAM_CATCHMENTS_COLUMN.csv\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(outDir, \"upstream_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate downstream polygons\n#############################################\nout_tab &lt;- prep_input_column(builder_dir, \"DOWNSTREAM\")\n\nReturning BUILDER table: 2025_04_15_1201_ROW_BLIT_i80_t80_DOWNSTREAM_CATCHMENTS_COLUMN.csv\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(outDir, \"downstream_poly.shp\"), append = FALSE)"
  }
]