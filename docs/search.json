[
  {
    "objectID": "vignettes/hydro.html",
    "href": "vignettes/hydro.html",
    "title": "Assessing hydrology on reserves",
    "section": "",
    "text": "Both functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\nTo estimate DCI index within a reserve (e.g., potential benchmarks, protected area), the user needs to provide the stream network layers that uses the same coordinate reference system (CRS) as the reserve layer..\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\nsource(\"./R/calcDCI_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/hydro.html#intro",
    "href": "vignettes/hydro.html#intro",
    "title": "Assessing hydrology on reserves",
    "section": "",
    "text": "Both functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\nTo estimate DCI index within a reserve (e.g., potential benchmarks, protected area), the user needs to provide the stream network layers that uses the same coordinate reference system (CRS) as the reserve layer..\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\nsource(\"./R/calcDCI_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderInput.html",
    "href": "vignettes/createBuilderInput.html",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‘CATCHNUM’.\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\npas &lt;- file.path(dirpath, \"data\", \"reserves_sample.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderInput.html#intro",
    "href": "vignettes/createBuilderInput.html#intro",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‘CATCHNUM’.\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\nnghbrs &lt;- neighbours(catchments_sf)\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path catchment layer\ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 10000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layer\ncatchments_sf &lt;- st_read(catchments)\n\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./createBuilderInput_dependencies.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n#Set access path \n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\npas &lt;- file.path(dirpath, \"data\", \"reserves_sample.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\npas_sf &lt;- st_read(pas)\n\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ninput_dir &lt;- \"Builder_input\"\nif (!dir.exists(file.path(dirpath, input_dir))) {\n  dir.create(file.path(dirpath, input_dir), recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data\", \"catchments.shp\")\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Read layers\ncatchments_sf &lt;- st_read(catchments)\n\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/seeds.html#usage",
    "href": "tools/seeds.html#usage",
    "title": "seeds()",
    "section": "Usage",
    "text": "Usage\nseeds(\n  catchments_sf,\n  filter_polygon = NULL,\n  areatarget_value = NULL,\n  areatarget_col = NULL,\n  areatarget_polygon = NULL,\n  areatarget_polygon_col = NULL\n)"
  },
  {
    "objectID": "tools/seeds.html#arguments",
    "href": "tools/seeds.html#arguments",
    "title": "seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nfilter_polygon: (Optional) sf polygon to filter catchments. Only catchments inside the polygon are kept.\nareatarget_value: (Optional) Single area target value (in m²) to apply to all seeds.\nareatarget_col: (Optional) Column in catchments_sf containing individual area targets.\nareatarget_polygon: (Optional) sf polygon object holding area target values, used via spatial join.\nareatarget_polygon_col: (Optional) Column in areatarget_polygon containing area target values."
  },
  {
    "objectID": "tools/seeds.html#output",
    "href": "tools/seeds.html#output",
    "title": "seeds()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble of seed catchments and their assigned area targets."
  },
  {
    "objectID": "tools/seeds.html#details",
    "href": "tools/seeds.html#details",
    "title": "seeds()",
    "section": "Details",
    "text": "Details\n\nFiltering\nIf no filter is provided, all catchments in catchments_sf will be added to the seeds table.\n\nTo filter using a column, use dplyr::filter() before passing catchments_sf to seeds().\nIf filter_polygon is used, filtering is based on whether the centroid (using sf::st_point_on_surface()) falls inside the polygon.\n\n\n\nArea Targets\nArea targets must be in square meters (m²). Provide one of the following (priority is top to bottom):\n\nSingle value: areatarget_value applies to all seeds.\nColumn-based: Values from areatarget_col in catchments_sf.\nSpatial join: Join with areatarget_polygon; values from areatarget_polygon_col. When multiple polygons overlap a catchment, the value with the most overlap is used."
  },
  {
    "objectID": "tools/seeds.html#examples",
    "href": "tools/seeds.html#examples",
    "title": "seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nseeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\n\n# Use column-based area targets\ncatchments_sample$area_target &lt;- 1000000000\nseeds(catchments_sf = catchments_sample, areatarget_col = \"area_target\")\n\n# Filter based on a column value\ncatchments_sample %&gt;%\n  filter(intact == 1) %&gt;%\n  seeds(catchments_sf = ., areatarget_value = 1000000000)\n\n# Filter using a spatial polygon\nref_poly &lt;- data.frame(\n  lon = c(-138.4, -138.1, -138.1, -138.4, -138.1, -138.1, -138, -138),\n  lat = c(64.3, 64.3, 64.1, 64.1, 64.3, 64.1, 64.1, 64.3),\n  Areatarget = c(rep(1000000000, 4), rep(2000000000, 4))\n) %&gt;%\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %&gt;%\n  group_by(Areatarget) %&gt;%\n  summarise(geometry = st_combine(geometry)) %&gt;%\n  st_cast(\"POLYGON\") %&gt;%\n  st_transform(st_crs(catchments_sample))\n\nseeds(\n  catchments_sf = catchments_sample,\n  filter_polygon = ref_poly,\n  areatarget_polygon = ref_poly,\n  areatarget_polygon_col = \"Areatarget\"\n)\n\n# save seeds as csv\nseed &lt;- seeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\nwrite.csv(seed, file=file.path(dirpath,\"Builder_input/seeds.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/neighbours.html#usage",
    "href": "tools/neighbours.html#usage",
    "title": "neighbours()",
    "section": "Usage",
    "text": "Usage\nneighbours(\n  catchments_sf\n)"
  },
  {
    "objectID": "tools/neighbours.html#arguments",
    "href": "tools/neighbours.html#arguments",
    "title": "neighbours()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM."
  },
  {
    "objectID": "tools/neighbours.html#output",
    "href": "tools/neighbours.html#output",
    "title": "neighbours()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble of neighbouring pairs with columns CATCHNUM and neighbours."
  },
  {
    "objectID": "tools/neighbours.html#examples",
    "href": "tools/neighbours.html#examples",
    "title": "neighbours()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nneighbours(catchments_sf = catchments_sample)\n\n# save neighbours as csv\nneighbour &lt;- neighbours(catchments_sf = catchments_sample)\nwrite.csv(neighbour, file=file.path(dirpath,\"Builder_input/neighbours.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/index_Representation.html",
    "href": "tools/index_Representation.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a variety of functions for two types of representation analysis:\nThe calc_dissimilarity() function compares the distributions of a raster layer between a conservation area and a broader study region that we are trying to represent. The closer the distributions of raster values, the lower the dissimilarity score. Values of 0.2 or less are considered ‘good’ representation.\nAnother approach focus on reaching target-based target using proportional representation. The latter ensure specific target areas of different representation classes are met in one or multiple conservation areas.\nRepresentation analyses typically include multiple layers assumed to represent a range of ecological processes. They often include climate layers, productivity, riparian zones etc. The goal of the representation analysis is to identify conservation areas that adequately capture the target amounts of representation classes (in our case NALC classes) deemed to be proportionally representative of the study region. Usually the target amounts should be met in full in a conservation area, rather than being split between multiple conservation areas. The idea being that the conservation area should provide a sufficient area for the ecological processes associated with specific target classes to operate. In a network of multiple conservation areas, different target classes and different ecological processes may therefore be represented by different conservation areas.\nThe xx main hydrology functions are:\n\nevaluate_criteria_using_clip\n\n\n\nThe function evaluate_criteria_using_clip() Clips the criteria raster to the conservation area and calculates the proportion of each class within it."
  },
  {
    "objectID": "tools/index_Representation.html#beacons-representation-r-functions",
    "href": "tools/index_Representation.html#beacons-representation-r-functions",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a variety of functions for two types of representation analysis:\nThe calc_dissimilarity() function compares the distributions of a raster layer between a conservation area and a broader study region that we are trying to represent. The closer the distributions of raster values, the lower the dissimilarity score. Values of 0.2 or less are considered ‘good’ representation.\nAnother approach focus on reaching target-based target using proportional representation. The latter ensure specific target areas of different representation classes are met in one or multiple conservation areas.\nRepresentation analyses typically include multiple layers assumed to represent a range of ecological processes. They often include climate layers, productivity, riparian zones etc. The goal of the representation analysis is to identify conservation areas that adequately capture the target amounts of representation classes (in our case NALC classes) deemed to be proportionally representative of the study region. Usually the target amounts should be met in full in a conservation area, rather than being split between multiple conservation areas. The idea being that the conservation area should provide a sufficient area for the ecological processes associated with specific target classes to operate. In a network of multiple conservation areas, different target classes and different ecological processes may therefore be represented by different conservation areas.\nThe xx main hydrology functions are:\n\nevaluate_criteria_using_clip\n\n\n\nThe function evaluate_criteria_using_clip() Clips the criteria raster to the conservation area and calculates the proportion of each class within it."
  },
  {
    "objectID": "tools/index_Representation.html#citation",
    "href": "tools/index_Representation.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/index_Builder.html",
    "href": "tools/index_Builder.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BUILDER is a user friendly software application, developed in C# .NET framework, to assist conservation planners with the design of ecological benchmarks. This package provides a set of R functions to call BUILDER and fetch the main output table. The partner package beaconstools provides functions to process and analyse output tables from BUILDER in R.\nBUILDER explicitly incorporates hydrologic connectivity for the integration of aquatic and terrestrial conservation planning in protected areas design. BUILDER constructs ecological benchmarks using a deterministic construction algorithm that aggregates catchments to a user defined size and intactness. For the purpose of this demo, we will refer to the conservation areas created by BUILDER as benchmarks, however BUILDER can also be used to design conservation areas not intended to serve as benchmarks.\nBUILDER constructs ecological benchmarks based on three principal criteria:\n\nIntactness, a measure of the absence of human industrial activity and a proxy for the intactness of biological and physical processes\nHydrologic connectivity of intact water catchments, as a measure of the integrity of aquatic systems\nSize, as a measure of the resilience of the system to disturbance"
  },
  {
    "objectID": "tools/index_Builder.html#beacons-builder",
    "href": "tools/index_Builder.html#beacons-builder",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BUILDER is a user friendly software application, developed in C# .NET framework, to assist conservation planners with the design of ecological benchmarks. This package provides a set of R functions to call BUILDER and fetch the main output table. The partner package beaconstools provides functions to process and analyse output tables from BUILDER in R.\nBUILDER explicitly incorporates hydrologic connectivity for the integration of aquatic and terrestrial conservation planning in protected areas design. BUILDER constructs ecological benchmarks using a deterministic construction algorithm that aggregates catchments to a user defined size and intactness. For the purpose of this demo, we will refer to the conservation areas created by BUILDER as benchmarks, however BUILDER can also be used to design conservation areas not intended to serve as benchmarks.\nBUILDER constructs ecological benchmarks based on three principal criteria:\n\nIntactness, a measure of the absence of human industrial activity and a proxy for the intactness of biological and physical processes\nHydrologic connectivity of intact water catchments, as a measure of the integrity of aquatic systems\nSize, as a measure of the resilience of the system to disturbance"
  },
  {
    "objectID": "tools/index_Builder.html#catchments",
    "href": "tools/index_Builder.html#catchments",
    "title": "BEACONs R Tools",
    "section": "Catchments",
    "text": "Catchments\nThe building blocks for BUILDER is a set of catchments with associated flow directions for the underlying stream network. This allows BUILDER to identify upstream and downstream catchments for any given location. Should we provide a brief description of the catchments dataset and how to download them?"
  },
  {
    "objectID": "tools/index_Builder.html#aggregation-algorithm",
    "href": "tools/index_Builder.html#aggregation-algorithm",
    "title": "BEACONs R Tools",
    "section": "Aggregation algorithm",
    "text": "Aggregation algorithm\nBUILDER ‘grows’ ecological benchmarks using a deterministic construction algorithm that aggregates catchments. This process enables intactness, size and hydrologic criteria to be incorporated into benchmark design.\nThe starting catchments for building benchmarks are called seeds. These can be selected using size and intactness criteria e.g., all catchments that are 100% intact and greater than 500km2. Starting from a seed, BUILDER grows a benchmark by aggregating neighbouring catchments that exceed the user defined catchment-level intactness threshold. As catchments are added, growth is prioritized in the upstream direction. This emphasizes inclusion of headwaters within benchmarks, and encourages the formation of benchmarks along stream networks. Further, by adding all eligible upstream catchments before re-querying for more, benchmarks are grown with a more compact shape. If re-querying were to occur after adding each upstream catchment, benchmarks would tend to grow along single streams, resulting in linear configurations. To further compact the shape of the benchmark, BUILDER prioritizes the addition of catchments within hydrological zones (i.e. Fundamental Drainage Areas, FDAs) associated with the benchmark before adding catchments in a neighbouring FDA.\nOnce all available upstream catchments are added, BUILDER grows downstream. Downstream growth adds all neighbouring catchments downstream of the catchment aggregation then re-queries for upstream catchments. Benchmarks are grown until:\n\nThere are no more neighbouring, intact catchments to add, or\nThe benchmarks area exceeds the user-specified Area Target.\n\nIf the latter occurs, and the area-weighted intactness of the benchmark exceeds the benchmark-level intactness threshold, then the benchmark is included in the output."
  },
  {
    "objectID": "tools/index_Builder.html#builder-r-functions",
    "href": "tools/index_Builder.html#builder-r-functions",
    "title": "BEACONs R Tools",
    "section": "BUILDER R Functions",
    "text": "BUILDER R Functions\nBEACONs BUILDER has 4 main functions:\n\nseeds\nreserve_seeds\nneighbours\nbuilder\n\n\nseeds\nThe function seeds() creates a seeds table, which is an input to builder().\nIt identifies seed catchments and assigns them an area target.\n\n\nreserve_seeds\nThe function reserve_seeds() creates a seeds table based on conservation areas, which is an input to builder().\nIt identifies seed catchments inside a conservation area and assigns them an area target.\n\n\nneighbours\nThe function neighbours() creates a table listing pairwise catchment neighbours. Used as an input to builder().\n\n\nbuilder\nThe function builder() prepares the input files and parameters and passes them to a command line version of BUILDER executable software. The function then fetches and returns the main BUILDER output table into the R environment."
  },
  {
    "objectID": "tools/index_Builder.html#process",
    "href": "tools/index_Builder.html#process",
    "title": "BEACONs R Tools",
    "section": "🏗️ Process",
    "text": "🏗️ Process\n\nPrepares input tables: neighbours, either seeds or reserve_seeds, and catchments.\nMake sure default parameters are relevant and Set BUILDER parameters such as catchment_level_intactness, conservation_area_intactness.\nbuilder() returns the *_COLUMN_All_Unique_BAs.csv file listing conservation areas and their catchments.\nSubsequent processing, such as creating polygons of benchmarks using builder() output and assessing ecological attributes is done using others BEACONs functions (see examples in section Articles)."
  },
  {
    "objectID": "tools/index_Builder.html#key-parameters",
    "href": "tools/index_Builder.html#key-parameters",
    "title": "BEACONs R Tools",
    "section": "🔧 Key Parameters",
    "text": "🔧 Key Parameters\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nArea target\nSet in the seeds table; minimum size (m²) for each conservation area.\n\n\nCatchment intactness\nMinimum intactness required for catchments to be included.\n\n\nConservation area intactness\nMinimum area-weighted intactness for a conservation area to be returned.\n\n\nArea target proportion\nAllows output of smaller areas (e.g., 0.9 returns areas &gt;= 90% of the area target)."
  },
  {
    "objectID": "tools/index_Builder.html#tip",
    "href": "tools/index_Builder.html#tip",
    "title": "BEACONs R Tools",
    "section": "💡 Tip",
    "text": "💡 Tip\nUse output_dir to preserve BUILDER’s complete outputs when running multiple builds. These files can be further analyzed using others BEACONs functions."
  },
  {
    "objectID": "tools/index_Builder.html#citation",
    "href": "tools/index_Builder.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/dci.html#usage",
    "href": "tools/dci.html#usage",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Usage",
    "text": "Usage\ncalc_dci(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)\n\ncalc_lwdci(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)"
  },
  {
    "objectID": "tools/dci.html#arguments",
    "href": "tools/dci.html#arguments",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Arguments",
    "text": "Arguments\nBoth functions need the following:\n\nCAs_sf: sf object of conservation areas in which to calculate DCI.\nstream_sf: sf object of river network. Must have streams grouped in a BASIN attribute.\nCAs_id: Column in CAs_sf specify unique identifier. Default is network.\nbuffer_width: (Optional) Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis."
  },
  {
    "objectID": "tools/dci.html#output",
    "href": "tools/dci.html#output",
    "title": "calc_dci() and calc_lwdci()",
    "section": "📤 Output",
    "text": "📤 Output\nA vector of numeric DCI or lwDCI values matching the input features."
  },
  {
    "objectID": "tools/dci.html#details",
    "href": "tools/dci.html#details",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Details",
    "text": "Details\nDeveloped by Cote et al. (2009), the Dendritic Connectivity Index quantifies “longitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network.” Longitudinal connectivity refers to connections between upstream and downstream sections of the network. The index is calculated as\n\n\n\nwhere li is the length of a stream (or river) section and L is the total length of the stream network within the benchmark. The index ranges from 0 (low longitudinal connectivity) to 1 (high longitudinal connectivity).\nIf the conservation areas overlap two ocean drainage, the use of calc_lwdci() is more suitable."
  },
  {
    "objectID": "tools/dci.html#examples",
    "href": "tools/dci.html#examples",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\nThe example below allow to estimate dci and lwdci for a set of conservation areas. Because the two functions returns a vector of index, the script calculate the respective indexes and integrate the results in the reserves object prior to save it as a new shapefile.\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Set working directory\nsetwd(\"your/path/to/downloads/folder\")\n\nsource(\"./R/hydrology.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves_sample.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams_sample.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, CAs_id = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, CAs_id = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "report-issues.html",
    "href": "report-issues.html",
    "title": "Reporting an Issue",
    "section": "",
    "text": "Reporting an Issue\nIf you’ve found a bug or something isn’t working as expected, please follow the instructions below before reporting:\n\nGo to our GitHub issues page and submit your bug report (access below).\nAdd a title by mentioning the function name(s) involved\nClearly describe the issue and behavior of the function(s).\nProvide a minimal reproducible example, if possible.\nInclude error messages or screenshots if available.\n\nClick the button below to go to our GitHub issues page and submit your bug report.\n\n 🚨 Report an Issue on GitHub"
  },
  {
    "objectID": "index_main.html",
    "href": "index_main.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Welcome to the BEACONs R tools pages!\nOver the years, BEACONs develops a series of function to ease conservation planning across the landscape. Those functions ranges from constructing ecological benchmarks and creating conservation area networks to assessing ecological representation. The functions are organized into different categories. This pages aims to document each function and demonstrate their use through example. The functions are intended for advanced users working with large-scale environmental data."
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Workflow",
    "section": "",
    "text": "clickable flowchart"
  },
  {
    "objectID": "methods.html#step-1",
    "href": "methods.html#step-1",
    "title": "Workflow",
    "section": "Step 1",
    "text": "Step 1"
  },
  {
    "objectID": "methods.html#step-2",
    "href": "methods.html#step-2",
    "title": "Workflow",
    "section": "Step 2",
    "text": "Step 2"
  },
  {
    "objectID": "methods.html#step-3",
    "href": "methods.html#step-3",
    "title": "Workflow",
    "section": "Step 3",
    "text": "Step 3"
  },
  {
    "objectID": "methods.html#step-4",
    "href": "methods.html#step-4",
    "title": "Workflow",
    "section": "Step 4",
    "text": "Step 4"
  },
  {
    "objectID": "methods.html#step-5",
    "href": "methods.html#step-5",
    "title": "Workflow",
    "section": "Step 5",
    "text": "Step 5"
  },
  {
    "objectID": "methods.html#step-6",
    "href": "methods.html#step-6",
    "title": "Workflow",
    "section": "Step 6",
    "text": "Step 6"
  },
  {
    "objectID": "methods.html#step-7",
    "href": "methods.html#step-7",
    "title": "Workflow",
    "section": "Step 7",
    "text": "Step 7"
  },
  {
    "objectID": "tools/builder.html#usage",
    "href": "tools/builder.html#usage",
    "title": "builder()",
    "section": "Usage",
    "text": "Usage\nbuilder(\n  catchments_sf, \n  data_source = \"catchment\",\n  seeds, \n  reserve_name,\n  neighbours, \n  out_dir = NULL,\n  builder_local_path, \n  catchment_level_intactness = 1, \n  conservation_area_intactness = 1, \n  area_target_proportion = 1, \n  area_type = \"land\", \n  construct_conservation_areas = TRUE,  \n  area_target_multiplier = 1,\n  handle_isolated_catchments = TRUE, \n  output_upstream = FALSE, \n  output_downstream = FALSE, \n  output_hydrology_metrics = FALSE,\n  area_land = \"Area_Land\", \n  area_water = \"Area_Water\",\n  skeluid = \"SKELUID\", \n  catchnum = \"CATCHNUM\", \n  subzone = \"FDA\", \n  zone = \"MDA\", \n  basin = \"BASIN\", \n  order1 = \"ORDER1\",\n  order2 = \"ORDER2\", \n  order3 = \"ORDER3\", \n  stream_length = \"STRMLEN\", \n  intactness = \"intact\", \n  isolated = \"Isolated\",\n  unique_identifier = \"PB\", \n  handler_summary = FALSE, \n  summary_intactness_props = '\"\"', \n  summary_area_target_props = '\"\"'\n)"
  },
  {
    "objectID": "tools/builder.html#arguments",
    "href": "tools/builder.html#arguments",
    "title": "builder()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with unique identifier column CATCHNUM.\ndata_source: Specify the seed type (catchment or reserve). Default is catchment.\nseeds: Seeds table from seeds() listing seed catchments and area targets.\nreserve_name: Reserve column listing the name of the reserve. Only used if data_source Reserve is selected.\nneighbours: Neighbours table from neighbours() listing all neighbouring pairs of catchments.\nout_dir: If provided, input (seeds, neighbours and catchments) files and output BUILDER tables will be saved to this directory. Otherwise a temp directory will be used. Function will attempt to create the directory if it doesn’t already exist.\nbuilder_local_path: Directory path to the benchmarkbuilder executable.\ncatchment_level_intactness: Minimum intactness value for catchment inclusion (between 0-1). i.e. if value of 1 is used, only 100% intact catchments will be used. Default is 1.\nconservation_area_intactness: Minimum area-weighted intactness of final conservation areas. Only conservation areas meeting this value will be returned. Default is 1.\narea_target_proportion: The proportion of the Area target that conservation areas need to meet (0-1) to be returned by the function. Default is 1.\narea_type: If ‘land’, only terrestrial areas are counted towards the area target. If ‘water’, only water areas are counter. If ‘landwater’, all areas are counted. Default is ‘land’.\nconstruct_conservation_areas: Should builder build conservation areas? Default is TRUE.\narea_target_multiplier: Multiplier applied to the area target in the seed list that allows for adjustments to the area target without having to remake the seeds table. Default is 1.\nhandle_isolated_catchments: Should small isolated catchments be merged into the conservation areas? Default is TRUE.\noutput_upstream: Should upstream catchments be calculated? Default is FALSE.\noutput_downstream: Should downstream catchments be calculated? Default is FALSE.\noutput_hydrology_metrics: Should hydrology metrics be calculated? Default is FALSE.\narea_land: Catchments column listing the area of land in each catchment. Default is ‘Area_Land’.\narea_water: Catchments column listing the area of water in each catchment. Default is ‘Area_Water’.\nskeluid: Catchments column listing the skeluid field. Default is ‘SKELUID’\ncatchnum: Catchments column listing the unique catchments ID. Default is ‘CATCHNUM’\nsubzone: Catchments column listing the hydrological subzone. Default is ‘FDA’\nzone: Catchments column listing the hydrological zone. Default is ‘MDA’\nbasin: Catchments column listing the basin field. Default is ‘BASIN’\norder1: Catchments column listing the order 1 field. Default is ‘ORDER1’\norder2: Catchments column listing the order 2 field. Default is ‘ORDER2’\norder3: Catchments column listing the order 3 field. Default is ‘ORDER3’\nstream_length: Catchments column listing stream length. Default is ‘STRMLEN’\nintactness: Catchments column listing the intactness value. Default is ‘intact’\nisolated: Catchments column identifying catchments isolated from the stream network. Default is ‘Isolated’\nunique_identifier: Prefix for conservation area names. Default is ‘PB’\nhandler_summary: Should a summary listing counts of available conservation areas at different intactness and area target proportions be created? Default is FALSE\nsummary_intactness_props: If a summary is created, provide the intactness proportions to be summarised in the format ‘0.7,0.8,0.9’.\nsummary_area_target_props: If a summary is created, provide the area target proportions to be summarised in the format ‘0.7,0.8,0.9’."
  },
  {
    "objectID": "tools/builder.html#output",
    "href": "tools/builder.html#output",
    "title": "builder()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble with column names representing conservation areas, and rows of catchments making up the conservation areas. If output_dir is provided, additional BUILDER output tables (e.g., hydrology, summary metrics) are saved."
  },
  {
    "objectID": "tools/builder.html#details",
    "href": "tools/builder.html#details",
    "title": "builder()",
    "section": "Details",
    "text": "Details\nThis function prepares the input tables (neighbours, seeds, catchments) required by BUILDER in a temp file, then creates a string of parameters that is passed to the BUILDER executable using system(). The BUILDER output tables are saved to the temp file, and the output table listing conservation area names and catchment lists is returned to the R session.\nThis function only returns the BUILDER output table describing the lists of catchments making up each conservation area. We typically recommend using the beaconstools package to calculate hydrology metrics, but hydrology information as well as other summary information is produced by BUILDER. If users want access to the complete set of BUILDER output tables (e.g. hydrology and summary information), a valid output directory can be provided in which case all input and output tables will be saved to that directory. If no output directory is provided a temp folder will be used and deleted after the function completes. As well as providing access to the full list of BUILDER output tables, an output directory is useful in a looped workflow with multiple calls to BUILDER producing multiple sets of output files. In this workflow a different output directory can be used to save each set of output files which can later be processed using the beaconstools package. The main output file listing conservation area names and their catchments is named “*_COLUMN_All_Unique_BAs.csv”."
  },
  {
    "objectID": "tools/builder.html#examples",
    "href": "tools/builder.html#examples",
    "title": "builder()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n** Prior to run the example, the benchmarkbuilder executable needs to be acquired by contacting the BEACONs Project.\n\nDownload and unzip BEACONs R Tools\nRun BUILDER\n\nThe main parameters to adjust when building conservation areas are: - data_source: Is the provided seed list catchment or reserve? - Area target: Set in the seeds table, this defines the minimum size for each conservation area. - Catchment-level intactness: Only catchments with intactness values greater than this value will be added to the conservation area. - Conservation area intactness: Only conservation areas with an area-weighted intactness greater than or equal to this value will be returned. - Area-target proportion: The proportion of the Area target that conservation areas need to meet. Allows output of conservation areas smaller than the area target (e.g. if no conservation areas meet 100% of the area target, area target multiplier can be lowered to 0.9 to search for smaller conservation areas).\n\nRunning ‘builder()’ using catchments seed type.\n\nlibrary(sf)\n\n########################\n##    PARAMS   \n########################\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- \"path/to/builder/folder\"\n\n# Folder path to unzipped BEACONs_R_Tools folder\ndest_folder &lt;- \"path/to/extract/folder\"\n\nsetwd(dest_folder)\n\n########################\n##    RUN   \n########################\nsource(\"./R/builder.R\")\nsource(\"./R/utils\")\n\n# Create the folder structure\nif (!dir.exists(file.path(dest_folder, \"Builder_output\"))) {\n  dir.create(file.path(dest_folder, \"Builder_output\"))\n}\n\n# Use all catchments as seeds with a single area target\ncatchments &lt;- st_read(\"./data/catchments_sample.shp\")\n\nnghbrs &lt;- neighbours(catchments)\nseed &lt;- seeds(catchments_sf = catchments, areatarget_value = 1000000000)\nbuilder(catchments_sf = catchments, seeds = seed, neighbours = nghbrs, out_dir = file.path(dest_folder, \"Builder_output\"), builder_local_path = builder_path)\n\nRunning ‘builder()’ using reserves seed type.\n\nlibrary(sf)\n\n########################\n##    PARAMS   \n########################\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- \"path/to/builder/folder\"\n\n# Folder path to unzipped BEACONs_R_Tools folder\ndest_folder &lt;- \"path/to/extract/folder\"\n\nsetwd(dest_folder)\n\n########################\n##    RUN   \n########################\nsource(\"./R/builder.R\")\nsource(\"./R/utils\")\n\n# Create the folder structure\nif (!dir.exists(file.path(dest_folder, \"Builder_output\"))) {\n  dir.create(file.path(dest_folder, \"Builder_output\"))\n}\n\n# Use conservation areas as reserve seeds\ncatchments &lt;- st_read(\"./data/catchments_sample.shp\")\nconservation_areas &lt;- st_read(\"./data/reserves_sample.shp\")\n\nnghbrs &lt;- neighbours(catchments)\nreserve_seed &lt;- reserve_seeds(catchments, CAs_sf=conservation_areas, CAs_id = \"reserve\", areatarget_value = 10000, joinType = \"INTERSECT\")\nbuilder(catchments_sf = catchments, data_source = \"Reserve\", seeds = reserve_seed, reserve_name = \"reserve\", neighbours = nghbrs, out_dir = file.path(dest_folder, \"Builder_output\"), builder_local_path = builder_path, catchment_level_intactness = 0.8, conservation_area_intactness = 0.8)"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#usage",
    "href": "tools/evaluate_criteria_using_clip.html#usage",
    "title": "evaluate_criteria_using_clip()",
    "section": "Usage",
    "text": "Usage\nevaluate_criteria_using_clip(\n  CAs_sf, \n  criteria_raster, \n  CAs_id = NULL, \n  class_values = c(), \n  set_target = FALSE, \n  target_size = NULL\n)"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#arguments",
    "href": "tools/evaluate_criteria_using_clip.html#arguments",
    "title": "evaluate_criteria_using_clip()",
    "section": "Arguments",
    "text": "Arguments\n\nCAs_sf: sf object of conservation areas.\ncriteria_raster: Raster object of the representation layer classified into categorical classes\nCAs_id: Column in CAs_sf specify unique identifier.\nclass_values: A vector of classes in representation_raster to generate targets for. Defaults to all classes in the representation_raster.\nset_target: Logical. Should the tibble return target size? Default is FALSE\ntarget_size: The area in km2 that targets will sum to. set target must be set to TRUE."
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#output",
    "href": "tools/evaluate_criteria_using_clip.html#output",
    "title": "evaluate_criteria_using_clip()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble with columns: - CAs_id (if provided) - class_value: the list of class_values} - area_km2: the area of each class_value in the CAs_sf} - class_proportion: area_km2/sum(area_km2)} - target_size (if provided) - target_km2 (if set_target = TRUE)"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#examples",
    "href": "tools/evaluate_criteria_using_clip.html#examples",
    "title": "evaluate_criteria_using_clip()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n\n# Load libraries\nlibrary(sf)\n\nLinking to GEOS 3.13.0, GDAL 3.10.1, PROJ 9.5.1; sf_use_s2() is TRUE\n\nlibrary(terra)\n\nterra 1.8.50\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:terra':\n\n    intersect, union\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n# Set working directory\n#setwd(\".\")\nsetwd(\"../\")\ndirpath &lt;- getwd()\nsource(\"./R/representation.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n\n#Set access path \nreserves_sf &lt;- st_read(file.path(dirpath, \"data/reserves_sample.shp\"))\n\nReading layer `reserves_sample' from data source \n  `E:\\MelinaStuff\\BEACONs\\git\\R_tools_public\\data\\reserves_sample.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -2063049 ymin: 815481.9 xmax: -1987393 ymax: 861999.6\nProjected CRS: NAD_1983_Albers\n\nnalc &lt;- rast(file.path(dirpath, \"data/nalc_sample.tif\"))\n\nresult &lt;- evaluate_criteria_using_clip(reserves_sf, nalc, CAs_id = \"reserve\")\n\n`summarise()` has grouped output by 'reserve'. You can override using the\n`.groups` argument.\n\n# ── To display landcover classes proportion per conservation areas ------------\nlibrary(readr)\nlibrary(ggplot2)\n\n# Read landcover color palette from files\nlandcover_colors &lt;- read_csv(file.path(dirpath, \"data/lc_cols.csv\"))\n\nRows: 11 Columns: 6\n\n\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (2): label, hex\ndbl (4): class_value, red, green, blue\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Join hex code to results\nresults &lt;- result %&gt;%\n  mutate(class_value = as.integer(class_value)) %&gt;%\n  left_join(landcover_colors, by = \"class_value\")\n\n# set number of piechart based on number of conservation areas.\nn_chart &lt;- length(unique(reserves_sf$reserve))\n\n# Plot proportion\nggplot(results,\n       aes(x = \"\", y = class_proportion, fill = label)) +  # use label for legend\n  geom_col(width = 1, colour = \"white\") +\n  coord_polar(theta = \"y\") +\n  facet_wrap(~ reserve) +\n  scale_fill_manual(values = setNames(results$hex, results$label)) +\n  labs(title = \"Class composition by conservation area\") +\n  theme_void() +\n  theme(strip.text = element_text(size = 12, face = \"bold\"),\n        plot.title = element_text(hjust = 0.5))\n\n\n\n\nPie charts of landcover class proportions by conservation area"
  },
  {
    "objectID": "tools/index_Hydrology.html",
    "href": "tools/index_Hydrology.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a range of hydrology functions for adding ecological attributes to conservation areas, such as identifying all watershed catchments upstream (or downstream), calculating their area and intactness values and calculating hydrological connectivity within each conservation area or network.\nThe 4 main hydrology functions are:\n\ncalc_dci\ncalc_lwdci\nget_upstream_catchments\nget_downstream_catchments\n\n\n\nThe function calc_dci() calculates dendritic connectivity index (DCI) for a set of conservation areas, which quantifies the “longitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network” (Cote et al. 2009).\n\n\n\nThe function calc_lwdci() computes a distinct DCI value for each group of BASIN streams within the conservation area. It then calculates a weighted average of these values, using the stream lengths in each BASIN as weights. It minimize the impact of fragmentation on streams inside a conservation areas, due to different ocean drainage basin, giving a more realistic picture of how much of the functional network remains connected for species movement.\n\n\n\nThe function get_upstream_catchments() calculates the area upstream of a giver polygon using catchments and stream flow attributes.\n\n\n\nThe function get_downstream_catchments() calculates the area downstream of a given polygon using catchments and stream flow attributes."
  },
  {
    "objectID": "tools/index_Hydrology.html#beacons-hydrology-r-functions",
    "href": "tools/index_Hydrology.html#beacons-hydrology-r-functions",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a range of hydrology functions for adding ecological attributes to conservation areas, such as identifying all watershed catchments upstream (or downstream), calculating their area and intactness values and calculating hydrological connectivity within each conservation area or network.\nThe 4 main hydrology functions are:\n\ncalc_dci\ncalc_lwdci\nget_upstream_catchments\nget_downstream_catchments\n\n\n\nThe function calc_dci() calculates dendritic connectivity index (DCI) for a set of conservation areas, which quantifies the “longitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network” (Cote et al. 2009).\n\n\n\nThe function calc_lwdci() computes a distinct DCI value for each group of BASIN streams within the conservation area. It then calculates a weighted average of these values, using the stream lengths in each BASIN as weights. It minimize the impact of fragmentation on streams inside a conservation areas, due to different ocean drainage basin, giving a more realistic picture of how much of the functional network remains connected for species movement.\n\n\n\nThe function get_upstream_catchments() calculates the area upstream of a giver polygon using catchments and stream flow attributes.\n\n\n\nThe function get_downstream_catchments() calculates the area downstream of a given polygon using catchments and stream flow attributes."
  },
  {
    "objectID": "tools/index_Hydrology.html#citation",
    "href": "tools/index_Hydrology.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/index_Spatial.html",
    "href": "tools/index_Spatial.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Spatial"
  },
  {
    "objectID": "tools/index_Spatial.html#citation",
    "href": "tools/index_Spatial.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/reserve_seeds.html#usage",
    "href": "tools/reserve_seeds.html#usage",
    "title": "reserve_seeds()",
    "section": "Usage",
    "text": "Usage\nreserve_seeds(\n  catchments_sf,\n  CAs_sf,\n  CAs_id = NULL,\n  areatarget_value = NULL,\n  joinType = NULL\n)"
  },
  {
    "objectID": "tools/reserve_seeds.html#arguments",
    "href": "tools/reserve_seeds.html#arguments",
    "title": "reserve_seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nCAs_sf: A character string. Name of the column holding conservation area unique identifiers.\nCAs_id: A character string. Name of the column holding conservation area unique identifiers.\nareatarget_value: (Optional) A single numeric value specifying the area target to apply to all seeds.\njoinType: A character string. Type of spatial join to identify catchments within conservation areas. Options are \"INTERSECT\" or \"CENTROID\". Default is \"CENTROID\"."
  },
  {
    "objectID": "tools/reserve_seeds.html#output",
    "href": "tools/reserve_seeds.html#output",
    "title": "reserve_seeds()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble of reserve seed catchments and their associated area targets."
  },
  {
    "objectID": "tools/reserve_seeds.html#examples",
    "href": "tools/reserve_seeds.html#examples",
    "title": "reserve_seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nreserves_sample &lt;- readRDS(\"data/reserves_sample.rds\")\nreserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_id = \"reserve\", areatarget_value = 1000000000)\n\n# save seeds as csv\nreserve_seed &lt;- reserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_id = \"reserve\", areatarget_value = 1000000000)\nwrite.csv(reserve_seed, file=file.path(dirpath,\"Builder_input/reserve_seeds.csv\"), na = \"\", row.names=FALSE)"
  },
  {
    "objectID": "tools/upstream_downstream.html#usage",
    "href": "tools/upstream_downstream.html#usage",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Usage",
    "text": "Usage\nget_upstream_catchments(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)\n\nget_downstream_catchments(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)"
  },
  {
    "objectID": "tools/upstream_downstream.html#arguments",
    "href": "tools/upstream_downstream.html#arguments",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Arguments",
    "text": "Arguments\nBoth functions need the following:\n\nCAs_sf: sf object of protected area polygons.\nCAs_id: String matching the unique identifier column in .\ncatchments_sf: sf object of the catchments dataset with unique identifier column: CATCHNUM ."
  },
  {
    "objectID": "tools/upstream_downstream.html#output",
    "href": "tools/upstream_downstream.html#output",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "📤 Output",
    "text": "📤 Output\nA tibble where each column name is a unique polygon id, and each row is a catchment making up the upstream area for the polygon. Blank rows are filled with NA. CATCHNUMs are returned as integers."
  },
  {
    "objectID": "tools/upstream_downstream.html#details",
    "href": "tools/upstream_downstream.html#details",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Details",
    "text": "Details\nThe upstream and downstream regions of a targeted polygons (i.e. conservation area) can inform on potential sources of external vulnerability due to water-mediated influences. For instance, assessing a conservation area’s vulnerability may involve examining upstream human disturbances—such as pollutant inputs or water diversions (e.g., dams)—while looking at downstream areas of a disturbed regions (i.e. mine) can provide insight into the potential spread of ecological impacts originating from the region."
  },
  {
    "objectID": "tools/upstream_downstream.html#examples",
    "href": "tools/upstream_downstream.html#examples",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\nThe example below allow to identify upstream and downstream areas and save them as layers.\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Set working directory\nsetwd(\"your/path/to/downloads/folder\")\n\nsource(\"./R/hydrology.R\")\nsource(\"./R/spatial.R\")\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves_sample.shp\")\ncatchments &lt;- file.path(dirpath, \"data/catchments_sample.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\ncatchments_sf &lt;- st_read(catchments)\n\nupstream_tbl &lt;- get_upstream_catchments(reserves_sf, colName, catchments_sf)\n\n\nupstream_sf &lt;- dissolve_catchments_from_table(catchments_sf, upstream_tbl, \"reserve\")\n\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html",
    "href": "vignettes/createBuilderPolygons.html",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction prep_input_column allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‘CATCHNUM’. prep_input_column needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‘BENCHMARKS’, ‘UPSTREAM’ or ‘DOWNSTREAM’. Default is ‘BENCHMARKS’.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./R/createBuilderPolygons_dependencies.R\")\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data/catchments.shp\")\n\n#Set access path catchments layer and initialize\ncatchments_sf &lt;- st_read(catchments)\n\n# Name given to identify unique benchmark\ncolName &lt;- \"PB\"\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"benchmarks_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  },
  {
    "objectID": "vignettes/createBuilderPolygons.html#intro",
    "href": "vignettes/createBuilderPolygons.html#intro",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction prep_input_column allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‘CATCHNUM’. prep_input_column needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‘BENCHMARKS’, ‘UPSTREAM’ or ‘DOWNSTREAM’. Default is ‘BENCHMARKS’.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\nsource(\"./R/createBuilderPolygons_dependencies.R\")\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\nbuilder_dir &lt;- file.path(dirpath, \"Builder_output\")\n\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n#Set access path \ncatchments &lt;- file.path(dirpath, \"data/catchments.shp\")\n\n#Set access path catchments layer and initialize\ncatchments_sf &lt;- st_read(catchments)\n\n# Name given to identify unique benchmark\ncolName &lt;- \"PB\"\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"benchmarks_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- prep_input_column(builder_dir, type = type)\n\n# Convert builder output tables to polygons\npoly_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\nwrite_sf(poly_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  }
]