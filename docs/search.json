[
  {
    "objectID": "tools/upstream_downstream.html#usage",
    "href": "tools/upstream_downstream.html#usage",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Usage",
    "text": "Usage\nget_upstream_catchments(\n  conservation_area_sf,\n  conservation_area_id,\n  catchments_sf\n)\n\nget_downstream_catchments(\n  conservation_area_sf,\n  conservation_area_id,\n  catchments_sf\n)"
  },
  {
    "objectID": "tools/upstream_downstream.html#arguments",
    "href": "tools/upstream_downstream.html#arguments",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Arguments",
    "text": "Arguments\nBoth functions need the following:\n\nconservation_area_sf: sf object of protected area polygons.\nconservation_area_id: String matching the unique identifier column in .\ncatchments_sf: sf object of the catchments dataset with unique identifier column: CATCHNUM ."
  },
  {
    "objectID": "tools/upstream_downstream.html#output",
    "href": "tools/upstream_downstream.html#output",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble where each column name is a unique polygon id, and each row is a catchment making up the upstream or downstream area for the polygon. Blank rows are filled with NA. CATCHNUMs are returned as integers."
  },
  {
    "objectID": "tools/upstream_downstream.html#details",
    "href": "tools/upstream_downstream.html#details",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Details",
    "text": "Details\nThe upstream and downstream regions of a targeted polygons (i.e.¬†conservation area) can inform on potential sources of external vulnerability due to water-mediated influences. For instance, assessing a conservation area‚Äôs vulnerability may involve examining upstream human disturbances‚Äîsuch as pollutant inputs or water diversions (e.g., dams)‚Äîwhile looking at downstream areas of a disturbed regions (i.e.¬†mine) can provide insight into the potential spread of ecological impacts originating from the region."
  },
  {
    "objectID": "tools/upstream_downstream.html#examples",
    "href": "tools/upstream_downstream.html#examples",
    "title": "get_upstream_catchments() andget_downstream_catchemnts()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\nThe example below allow to identify upstream and downstream areas and save them as layers.\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Set working directory\nsetwd(\"your/path/to/downloads/folder\")\n\nsource(\"./R/hydrology.R\")\nsource(\"./R/spatial.R\")\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves_sample.shp\")\ncatchments &lt;- file.path(dirpath, \"data/catchments_sample.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\ncatchments_sf &lt;- st_read(catchments)\n\nupstream_tbl &lt;- get_upstream_catchments(reserves_sf, colName, catchments_sf)\n\n# Turn the tibble into sf object\nupstream_sf &lt;- dissolve_catchments_from_table(catchments_sf, upstream_tbl, colName)\n\n#Plot results\nplot(st_geometry(catchments_sf), col = \"lightblue\", main = \"Upstream Catchments Example\")\nplot(st_geometry(upstream_sf), col = \"green\", add = TRUE)\nplot(st_geometry(reserves_sf), col = \"red\", add = TRUE)"
  },
  {
    "objectID": "tools/reserve_seeds.html#usage",
    "href": "tools/reserve_seeds.html#usage",
    "title": "reserve_seeds()",
    "section": "Usage",
    "text": "Usage\nreserve_seeds(\n  catchments_sf,\n  CAs_sf,\n  CAs_id = NULL,\n  areatarget_value = NULL,\n  joinType = NULL\n)"
  },
  {
    "objectID": "tools/reserve_seeds.html#arguments",
    "href": "tools/reserve_seeds.html#arguments",
    "title": "reserve_seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nCAs_sf: A character string. Name of the column holding conservation area unique identifiers.\nCAs_id: A character string. Name of the column holding conservation area unique identifiers.\nareatarget_value: (Optional) A single numeric value specifying the area target to apply to all seeds.\njoinType: A character string. Type of spatial join to identify catchments within conservation areas. Options are \"INTERSECT\" or \"CENTROID\". Default is \"CENTROID\"."
  },
  {
    "objectID": "tools/reserve_seeds.html#output",
    "href": "tools/reserve_seeds.html#output",
    "title": "reserve_seeds()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of reserve seed catchments and their associated area targets."
  },
  {
    "objectID": "tools/reserve_seeds.html#examples",
    "href": "tools/reserve_seeds.html#examples",
    "title": "reserve_seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nreserves_sample &lt;- readRDS(\"data/reserves_sample.rds\")\nreserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_id = \"reserve\", areatarget_value = 1000000000)\n\n# save seeds as csv\nreserve_seed &lt;- reserve_seeds(catchments_sf = catchments_sample, CAs_sf = reserves_sample, CAs_id = \"reserve\", areatarget_value = 1000000000)\nwrite.csv(reserve_seed, file=file.path(dirpath,\"Builder_input/reserve_seeds.csv\"), na = \"\", row.names=FALSE)"
  },
  {
    "objectID": "tools/index_Spatial.html",
    "href": "tools/index_Spatial.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Spatial\nBEACONs developed a collection of spatial functions that provide essential utilities for spatial analysis within the workflow. These functions are designed to work in combination with representation, hydrology, and builder functions, supporting tasks such as data preparation, spatial overlay, geometric processing, and summarization of spatial attributes.\nThe xx main spatial functions are:"
  },
  {
    "objectID": "tools/index_Spatial.html#citation",
    "href": "tools/index_Spatial.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/index_Hydrology.html",
    "href": "tools/index_Hydrology.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a range of hydrology functions for adding ecological attributes to conservation areas, such as identifying all watershed catchments upstream (or downstream), calculating their area and intactness values and calculating hydrological connectivity within each conservation area or network.\nThe 4 main hydrology functions are:\n\ncalc_dci\ncalc_lwdci\nget_upstream_catchments\nget_downstream_catchments\n\n\n\nThe function calc_dci() calculates dendritic connectivity index (DCI) for a set of conservation areas, which quantifies the ‚Äúlongitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network‚Äù (Cote et al.¬†2009).\n\n\n\nThe function calc_lwdci() computes a distinct DCI value for each group of BASIN streams within the conservation area. It then calculates a weighted average of these values, using the stream lengths in each BASIN as weights. It minimize the impact of fragmentation on streams inside a conservation areas, due to different ocean drainage basin, giving a more realistic picture of how much of the functional network remains connected for species movement.\n\n\n\nThe function get_upstream_catchments() calculates the area upstream of a giver polygon using catchments and stream flow attributes.\n\n\n\nThe function get_downstream_catchments() calculates the area downstream of a given polygon using catchments and stream flow attributes."
  },
  {
    "objectID": "tools/index_Hydrology.html#beacons-hydrology-r-functions",
    "href": "tools/index_Hydrology.html#beacons-hydrology-r-functions",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a range of hydrology functions for adding ecological attributes to conservation areas, such as identifying all watershed catchments upstream (or downstream), calculating their area and intactness values and calculating hydrological connectivity within each conservation area or network.\nThe 4 main hydrology functions are:\n\ncalc_dci\ncalc_lwdci\nget_upstream_catchments\nget_downstream_catchments\n\n\n\nThe function calc_dci() calculates dendritic connectivity index (DCI) for a set of conservation areas, which quantifies the ‚Äúlongitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network‚Äù (Cote et al.¬†2009).\n\n\n\nThe function calc_lwdci() computes a distinct DCI value for each group of BASIN streams within the conservation area. It then calculates a weighted average of these values, using the stream lengths in each BASIN as weights. It minimize the impact of fragmentation on streams inside a conservation areas, due to different ocean drainage basin, giving a more realistic picture of how much of the functional network remains connected for species movement.\n\n\n\nThe function get_upstream_catchments() calculates the area upstream of a giver polygon using catchments and stream flow attributes.\n\n\n\nThe function get_downstream_catchments() calculates the area downstream of a given polygon using catchments and stream flow attributes."
  },
  {
    "objectID": "tools/index_Hydrology.html#citation",
    "href": "tools/index_Hydrology.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/fetch_builder_output.html#usage",
    "href": "tools/fetch_builder_output.html#usage",
    "title": "fetch_builder_output()",
    "section": "Usage",
    "text": "Usage\nfetch_builder_output(builder_dir,\n  type = \"BENCHMARKS\"\n)"
  },
  {
    "objectID": "tools/fetch_builder_output.html#arguments",
    "href": "tools/fetch_builder_output.html#arguments",
    "title": "fetch_builder_output()",
    "section": "Arguments",
    "text": "Arguments\n\nbuilder_dir: Path to the Builder output directory.\ntype: Type of output to retrieve. Must be one of \"BENCHMARKS\", \"UPSTREAM\", or \"DOWNSTREAM\". Default is \"BENCHMARKS\"."
  },
  {
    "objectID": "tools/fetch_builder_output.html#output",
    "href": "tools/fetch_builder_output.html#output",
    "title": "fetch_builder_output()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of neighbouring pairs with columns CATCHNUM and neighbours."
  },
  {
    "objectID": "tools/fetch_builder_output.html#examples",
    "href": "tools/fetch_builder_output.html#examples",
    "title": "fetch_builder_output()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load required libraries\nlibrary(dplyr)\nlibrary(utils)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\n# Set working directory\ndirpath &lt;- \"path/to/BEACONs_R_Tools\"\nbuilder_outdir &lt;- \"path/to/builder/out_dir\"\n\nsetwd(dirpath)\nsource(\"./R/builder.R\")\n\n#Set access path catchments layer and initialize\ncatchments_sf &lt;- st_read(file.path(dirpath,\"data\",\"catchments_sample.shp\"))\n\n# Prefix given to identify unique conservation areas\ncolName &lt;- \"PB\"\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Map potential conservation areas generated by BUILDER\nout_tab &lt;- fetch_builder_output(builder_outdir, type = \"BENCHMARKS\")\n\n# Convert builder output tables to polygons\nPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments_sf, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n# Pick random set of 12 to display\nPBx_sample &lt;- PBx_sf %&gt;%\n  slice_sample(n = 12)\n\n# Set color palette\nn &lt;- nrow(PBx_sample)\npalette &lt;- brewer.pal(min(n, 12), \"Set3\")\n\n# Plot catchments and conservation areas\nggplot() +\n  geom_sf(data = catchments_sf, fill = \"grey90\", color = \"black\", alpha = 0.3) +\n  geom_sf(data = PBx_sample, aes(fill = PB), color = \"black\", alpha = 0.7) +\n  scale_fill_manual(values = palette) +\n  labs(\n    title = \"Distinct Potential Conservation Areas\",\n    fill = \"Conservation ID\"\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "tools/dissolve_catchments_from_table.html#usage",
    "href": "tools/dissolve_catchments_from_table.html#usage",
    "title": "dissolve_catchments_from_table()",
    "section": "Usage",
    "text": "Usage\ndissolve_catchments_from_table(\n  catchments_sf,\n  input_table,\n  out_feature_id=NULL,\n  calc_area = FALSE,\n  intactness_id = NULL,\n  dissolve_list = c(), \n  drop_table = NULL\n)"
  },
  {
    "objectID": "tools/dissolve_catchments_from_table.html#arguments",
    "href": "tools/dissolve_catchments_from_table.html#arguments",
    "title": "dissolve_catchments_from_table()",
    "section": "Arguments",
    "text": "Arguments\nthe function need the following:\n\ncatchments_sf: sf object of the catchments dataset with unique identifier column: CATCHNUM.\ninput_table: Data frame where column names are polygon names and rows are catchments making up each polygon. e.g.¬†output from get_upstream_catchments()(upstream_downstream.qmd).\nout_feature_id: String representing the output column name holding the polygon unique identifiers.\ncalc_area: If TRUE, an area_km2 column is added to the output containing the polygon area.\nintactness_id: Optional string identifying an intactness column (values between 0 and 1) in catchments_sf. If provided, used to calculate the area weighted intactness (AWI) of the dissolved polygons.\ndissolve_list: Vector of columns in to include in the output. Defaults to colnames(input_table). Can also dissolve multiple columns from together by combining column names with (e.g.¬†PB_0001__PB_0002).\ndrop_table: A table in the same format listing catchments to be dropped from the dissolve area."
  },
  {
    "objectID": "tools/dissolve_catchments_from_table.html#output",
    "href": "tools/dissolve_catchments_from_table.html#output",
    "title": "dissolve_catchments_from_table()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA sf object of polygons with unique identifier column ."
  },
  {
    "objectID": "tools/dissolve_catchments_from_table.html#details",
    "href": "tools/dissolve_catchments_from_table.html#details",
    "title": "dissolve_catchments_from_table()",
    "section": "Details",
    "text": "Details\nThe is in the form exported from the beaconsbuilder package, where each column lists catchment ids, and each column name represents the unique identifier of the output polygon.\nThis function is used to create conservation area polygons using tables created by the beaconsbuilder package, and upstream polygons using tables created by [get_upstream_catchments()].\nThe optional parameter can be used to filter the column names in that will be dissolved. The can also contain combinations of column name separated by , in this case the output polygon will dissolve the combined area of catchments from all columns in the string. For example, the string ‚ÄúPA1__PA2‚Äù in the will output a polygon representing the dissolved area of all catchments listed in the PA1 and PA2 columns of .\nThe main application of is to remove conservation area catchments from the dissolved area when dissolving upstream catchments tables. See vignette(‚Äòoverview‚Äô) for an example."
  },
  {
    "objectID": "tools/dissolve_catchments_from_table.html#examples",
    "href": "tools/dissolve_catchments_from_table.html#examples",
    "title": "dissolve_catchments_from_table()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\nThe example below allow to identify upstream and downstream areas and save them as layers.\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Set working directory\nsetwd(\"your/path/to/downloads/folder\")\n\nsource(\"./R/hydrology.R\")\nsource(\"./R/spatial.R\")\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves_sample.shp\")\ncatchments &lt;- file.path(dirpath, \"data/catchments_sample.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\ncatchments_sf &lt;- st_read(catchments)\n\nupstream_tbl &lt;- get_upstream_catchments(reserves_sf, colName, catchments_sf)\n\n# Turn the tibble into sf object\nupstream_sf &lt;- dissolve_catchments_from_table(catchments_sf, upstream_tbl, colName)\n\n#Plot results\nplot(st_geometry(catchments_sf), col = \"lightblue\", main = \"Upstream Catchments Example\")\nplot(st_geometry(upstream_sf), col = \"green\", add = TRUE)\nplot(st_geometry(reserves_sf), col = \"red\", add = TRUE)"
  },
  {
    "objectID": "tools/calc_dissimilarity.html#usage",
    "href": "tools/calc_dissimilarity.html#usage",
    "title": "calc_dissimilarity()",
    "section": "Usage",
    "text": "Usage\ncalc_dissimilarity(\n  reserves_sf, \n  reserves_id,\n  reference_sf, \n  raster_layer, \n  raster_type, \n  categorical_class_values=c(),\n  plot_out_dir=NULL\n  categorical_class_labels=data.frame()\n)"
  },
  {
    "objectID": "tools/calc_dissimilarity.html#arguments",
    "href": "tools/calc_dissimilarity.html#arguments",
    "title": "calc_dissimilarity()",
    "section": "Arguments",
    "text": "Arguments\n\nreserves_sf: sf object with unique id column named network.\nreserves_id: String matching the unique identifier column in .\nreference_sf: sf object of the reference area to compare against.\nraster_layer: Raster object that will be clipped to the reference and reserve areas, with crs matching reserves_sf.\nraster_type: ‚Äòcategorical‚Äô will use Bray-Curtis, ‚Äòcontinuous‚Äô will use KS-statistic.\ncategorical_class_values: Vector of raster values in raster_layer of type ‚Äòcategorical‚Äô to include in the calculation. Allows unwanted values to be dropped. Defaults to include all non-NA values.\nplot_out_dir: Path to folder in which to save plots. Default is not to create plots. Only creates plots if valid file path is provided. Dir will be created if it doesn‚Äôt exist.\ncategorical_class_labels: Optional data.frame object with columns values and labels indicating the label to use in Bray-Curtis graphs for each raster value. Defaults to using the raster values. Labels can be provided for all or a subset of values. See examples."
  },
  {
    "objectID": "tools/calc_dissimilarity.html#output",
    "href": "tools/calc_dissimilarity.html#output",
    "title": "calc_dissimilarity()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA vector of dissimilarity values matching the order of the input reserves_sf. Optionally a dissimilarity plot saved in the plot_out_dir for each computed value."
  },
  {
    "objectID": "tools/calc_dissimilarity.html#examples",
    "href": "tools/calc_dissimilarity.html#examples",
    "title": "calc_dissimilarity()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(exactextractr)\nlibrary(here)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsetwd(dirpath)\nsource(\"./R/representation.R\")\nsource(\"./R/utils.R\")\n\n#Set access path \nreserves_sf &lt;- st_read(file.path(dirpath, \"data/reserves_sample.shp\"), quiet = TRUE)\nreference_sf &lt;- st_read(file.path(dirpath, \"data/reference_area_sample.shp\"), quiet = TRUE)\nnalc &lt;- rast(file.path(dirpath, \"data/nalc_sample.tif\"))\n\ncolName &lt;- \"reserve\"\n\nresult &lt;- calc_dissimilarity(reserves_sf, colName, reference_sf, nalc, 'categorical')"
  },
  {
    "objectID": "report-issues.html",
    "href": "report-issues.html",
    "title": "Reporting an Issue",
    "section": "",
    "text": "Reporting an Issue\nIf you‚Äôve found a bug or something isn‚Äôt working as expected, please follow the instructions below before reporting:\n\nGo to our GitHub issues page and submit your bug report (access below).\nAdd a title by mentioning the function name(s) involved\nClearly describe the issue and behavior of the function(s).\nProvide a minimal reproducible example, if possible.\nInclude error messages or screenshots if available.\n\nClick the button below to go to our GitHub issues page and submit your bug report.\n\n üö® Report an Issue on GitHub"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "Welcome to the BEACONs R tools pages!\nOver the years, BEACONs develops a series of function to ease conservation planning across the landscape. Those functions ranges from constructing ecological benchmarks and creating conservation area networks to assessing ecological representation. The functions are organized into different categories. This pages aims to document each function and demonstrate their use through example. The functions are intended for advanced users working with large-scale environmental data."
  },
  {
    "objectID": "downloads/vignettes/createBuilderInput.html",
    "href": "downloads/vignettes/createBuilderInput.html",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‚ÄòCATCHNUM‚Äô.\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments_sample.shp\"))\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Generate neighbour table\nnghbrs &lt;- neighbours(catchments_sf)\n\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\nlibrary(dplyr)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments &lt;- st_read(file.path(dirpath, \"data\", \"catchments.shp\"))\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 100000000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments_sample.shp\"))\npas_sf &lt;- st_read(file.path(dirpath, \"data\", \"reserves_sample.shp\"))\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\n\n# Save\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path and initialize \ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments.shp\"))\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "downloads/vignettes/createBuilderInput.html#intro",
    "href": "downloads/vignettes/createBuilderInput.html#intro",
    "title": "Create Builder input",
    "section": "",
    "text": "This script creates the three required input to run BUILDER (neighbour, seeds and catchments tables).\nThe first step is to locate the catchments layer and point on an output directory where the derived files will be saved. The script uses three BUILDER functions: neighbour, seeds and reserve_seeds.\nThe neighbours() function calculates a list of neighbouring CATCHNUM pairs and returns them in a long tibble. Neighbours are defined as having at least on point in common (within 0.1m).\nThe seeds() function creates a list of seed catchments and area targets. Prior to run the function, the user can apply a filter on the catchments dataset by specifying the level of intactness or the STHRALER index the seeds should have.\nThe reserve_seeds() function creates a seeds table based on conservation areas.\nIt identifies seed catchments inside a conservation area and assigns them an area target.\nAll functions are input to builder() and need the catchments dataset with unique identifier column ‚ÄòCATCHNUM‚Äô.\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments_sample.shp\"))\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Generate neighbour table\nnghbrs &lt;- neighbours(catchments_sf)\n\nwrite.csv(nghbrs, file=file.path(dirpath, input_dir, \"nghbrs.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\nlibrary(dplyr)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments &lt;- st_read(file.path(dirpath, \"data\", \"catchments.shp\"))\n\n##OPTION: Filter potential seeds according to catchments intactness and STHRALER index\nintactColname &lt;- \"intactKBA\" # set catchment intactness column\nintact_threshold &lt;- 0.9      # set catchment intactness threshold\nSTRAHLER_ref &lt;- NULL         # set STRAHLER index\n\n##OPTION: Set area target value by choosing one of the following options. Leave argument to NULL  if not chosen\n## Option 1:\nareatarget &lt;- 100000000 #ex : areatarget &lt;- 10000\n## Option 2:\nareatarget_col &lt;- NULL #ex : areatarget_col &lt;- \"area_thres\" \n## Option 3:\nareatarget_poly &lt;- NULL # ex: areatarget_poly &lt;- st_read(file.path(dirpath, \"data\", \"poly_areatarget.shp\"))\nareatarget_poly_col &lt;- NULL # ex: areatarget_poly_col &lt;-\"area_thres\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Filter catchments based on intactness and STRAHLER index, create seeds and convert to csv\nseed_sf &lt;- catchments_sf %&gt;%\n  dplyr::filter(.data[[intactColname]] &gt;= intact_threshold, \n         if (!is.null(STRAHLER_ref)) STRAHLER == as.numeric(STRAHLER_ref) else TRUE)\n\nif (!is.null(areatarget)) {\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_value = as.numeric(areatarget))\n} else if (!is.null(areatarget_col)) {\n  # If areatarget is found in a column\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_col = areatarget_col)\n} else if (!is.null(areatarget_poly)) {\n  # If area target is found in a polygon that intersect the catchments_sf\n  seed &lt;- seeds(catchments_sf = seed_sf, areatarget_polygon = areatarget_poly, areatarget_polygon_col = areatarget_poly_col)\n} else {\n  stop(\"You need to set at least one option\") # Handle case where neither exists\n}\n\nwrite.csv(seed, file=file.path(dirpath, input_dir, \"seeds.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(utils)\n\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsource(\"./R/builder.R\")\nsource(\"./R/utils.R\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path catchment layer and initialize\ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments_sample.shp\"))\npas_sf &lt;- st_read(file.path(dirpath, \"data\", \"reserves_sample.shp\"))\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n\nreserve_seed &lt;- reserve_seeds(catchments_sf, CAs_sf=pas_sf, CAs_name = \"PARENT_ID\", areatarget_value = 10000, joinType = \"INTERSECT\")\n\n# Save\nwrite.csv(reserve_seed, file=file.path(dirpath, input_dir, \"reserve_seeds.csv\"), row.names=FALSE) \n\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(utils)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\n# Create the folder structure\ninput_dir &lt;- file.path(dirpath, \"Builder_input\")\nif (!dir.exists(input_dir)) {\n  dir.create(input_dir, recursive = TRUE)\n}\n\n#Set access path and initialize \ncatchments_sf &lt;- st_read(file.path(dirpath, \"data\", \"catchments.shp\"))\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\ncatchment &lt;- catchments_sf %&gt;%\n  st_drop_geometry()\nwrite.csv(catchment, file=file.path(dirpath, input_dir, \"catchments.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "downloads/vignettes/assessHydro.html",
    "href": "downloads/vignettes/assessHydro.html",
    "title": "Assessing hydrology on reserves",
    "section": "",
    "text": "Both functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\nTo estimate DCI index within a reserve (e.g., potential benchmarks, protected area), the user needs to provide the stream network layers that uses the same coordinate reference system (CRS) as the reserve layer..\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- \"path/to/BEACONs_R_tools\"\n\nset(dirpath)\nsource(\"./R/hydrology.R\")\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "downloads/vignettes/assessHydro.html#intro",
    "href": "downloads/vignettes/assessHydro.html#intro",
    "title": "Assessing hydrology on reserves",
    "section": "",
    "text": "Both functions need the following:\n\nreserves: Point to a polygon sf object\nstreams: Point to an stream_sf object. The provided streams need to have information on BASIN.\ncol_name: Column name holding the unique ID of the pas_sf. Default is network.\nbuffer_width: Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis.\n\nTo estimate DCI index within a reserve (e.g., potential benchmarks, protected area), the user needs to provide the stream network layers that uses the same coordinate reference system (CRS) as the reserve layer..\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- \"path/to/BEACONs_R_tools\"\n\nset(dirpath)\nsource(\"./R/hydrology.R\")\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, col_name = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, col_name = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "downloads/vignettes/createBuilderPolygons.html",
    "href": "downloads/vignettes/createBuilderPolygons.html",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction fetch_builder_output allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‚ÄòCATCHNUM‚Äô. fetch_builder_output needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‚ÄòBENCHMARKS‚Äô, ‚ÄòUPSTREAM‚Äô or ‚ÄòDOWNSTREAM‚Äô. Default is ‚ÄòBENCHMARKS‚Äô.\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(utils)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(here)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\n# Source BEACONs functions\nsource(file.path(dirpath,\"R/spatial.R\"))\nsource(file.path(dirpath,\"R/builder.R\"))\nsource(file.path(dirpath,\"R/utils.R\"))\n\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- here(\"builder\")\n\n# Set Builder output path (create the folder structure if missing)\nbuilder_dir &lt;- file.path(dirpath, \"output/Builder_output\")\nif (!dir.exists(builder_dir)) {\n  dir.create(builder_dir)\n}\n\n# Create the folder structure to receive output polygons\nout_dir &lt;- file.path(dirpath, \"output/shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n# Prefix given to identify unique conservation areas\ncolName &lt;- \"PB\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n\n# Use conservation areas as reserve seeds\ncatchments &lt;- st_read(file.path(dirpath,\"data/catchments_sample.shp\"))\n\nReading layer `catchments_sample' from data source \n  `E:\\MelinaStuff\\BEACONs\\git\\R_tools_public\\data\\catchments_sample.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 108 features and 15 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -2073549 ymin: 752749.6 xmax: -1946333 ymax: 861999.6\nProjected CRS: NAD_1983_Albers\n\nconservation_areas &lt;- st_read(file.path(dirpath,\"data/reserves_sample.shp\"))\n\nReading layer `reserves_sample' from data source \n  `E:\\MelinaStuff\\BEACONs\\git\\R_tools_public\\data\\reserves_sample.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -2063049 ymin: 815481.9 xmax: -1987393 ymax: 861999.6\nProjected CRS: NAD_1983_Albers\n\n# Run BUILDER\nnghbrs &lt;- neighbours(catchments)\nseed &lt;- seeds(catchments, areatarget_value = 100000000)\nbuilder(catchments_sf = catchments, data_source = \"catchment\", seeds = seed, neighbours = nghbrs, out_dir = builder_dir, builder_local_path = builder_path, catchment_level_intactness = 0.8, conservation_area_intactness = 1, output_upstream = TRUE, output_downstream = TRUE)\n\n# A tibble: 4 x 44\n  PB_94784 PB_95575 PB_95583 PB_95840 PB_95876 PB_95898 PB_95949 PB_96020\n     &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n1    94784    95575    95583    95840    95876    95898    95949    96020\n2    94837    95831    95831    95831    96075    95629    95840    95949\n3       NA       NA    95575       NA    97226       NA    95831    95840\n4       NA       NA       NA       NA       NA       NA       NA       NA\n# i 36 more variables: PB_96075 &lt;int&gt;, PB_97226 &lt;int&gt;, PB_97345 &lt;int&gt;,\n#   PB_97440 &lt;int&gt;, PB_97971 &lt;int&gt;, PB_98263 &lt;int&gt;, PB_98271 &lt;int&gt;,\n#   PB_98487 &lt;int&gt;, PB_98559 &lt;int&gt;, PB_98569 &lt;int&gt;, PB_98723 &lt;int&gt;,\n#   PB_98912 &lt;int&gt;, PB_98960 &lt;int&gt;, PB_99037 &lt;int&gt;, PB_99170 &lt;int&gt;,\n#   PB_99304 &lt;int&gt;, PB_99401 &lt;int&gt;, PB_99409 &lt;int&gt;, PB_99418 &lt;int&gt;,\n#   PB_99428 &lt;int&gt;, PB_99923 &lt;int&gt;, PB_99941 &lt;int&gt;, PB_100028 &lt;int&gt;,\n#   PB_100140 &lt;int&gt;, PB_100688 &lt;int&gt;, PB_100869 &lt;int&gt;, PB_100969 &lt;int&gt;, ...\n\n#############################################\n#  Generate potential conservation areas polygons\n#############################################\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\nPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\nupPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\ndownPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n# Map example\n# Get the first conservation area ID\nfirst_pb_id &lt;- PBx_sf$PB[13]\n\n# Filter all layers for this conservation area\npb1      &lt;- PBx_sf[PBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Conservation Area\")\nup_pb1   &lt;- upPBx_sf[upPBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Upstream\")\ndown_pb1 &lt;- downPBx_sf[downPBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Downstream\")\n\n# Combine layers \noverlay_data &lt;- rbind(pb1, up_pb1, down_pb1)\n\n# Plot all layers together\nggplot() +\n  geom_sf(data = catchments, fill = NA, color = \"black\", size = 0.2) +\n  geom_sf(data = overlay_data, aes(fill = type), color = \"black\", alpha = 0.6) +\n  scale_fill_manual(\n    name = \"Type\",\n    values = c(\n      \"Conservation Area\" = \"tan\",\n      \"Upstream\" = \"green4\",\n      \"Downstream\" = \"steelblue1\"\n    )\n  ) +\n  labs(\n    title = paste(\"Conservation Area and Related Units:\", first_pb_id),\n    subtitle = \"Mapped with upstream and downstream polygons\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n\n\n\n\n\n\n\n# Save \nwrite_sf(PBx_sf, dsn =file.path(out_dir, \"CAs_poly.shp\"), append = FALSE)\nwrite_sf(upPBx_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\nwrite_sf(downPBx_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  },
  {
    "objectID": "downloads/vignettes/createBuilderPolygons.html#intro",
    "href": "downloads/vignettes/createBuilderPolygons.html#intro",
    "title": "Create builder polygons",
    "section": "",
    "text": "This script generates potential benchmarks, as well as upstream and downstream polygons based on the BUILDER output.\nThe first step is to locate catchments layer and specify the directory where BUILDER output were saved.\nThese polygons are then used to assess dendritic connectivity by clipping the stream network to each polygon and analyzing how water flows within its boundaries.\n\n\nFunction fetch_builder_output allow to read Builder output tables that uses column format. The output can then be passed to dissolve_catchment_from_table to generate polygons using enumerated ‚ÄòCATCHNUM‚Äô. fetch_builder_output needs the following:\n\nout_dir: Point to a directory that contains Builder output\ntype: Indicate which file to read. Type can be ‚ÄòBENCHMARKS‚Äô, ‚ÄòUPSTREAM‚Äô or ‚ÄòDOWNSTREAM‚Äô. Default is ‚ÄòBENCHMARKS‚Äô.\n\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(utils)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(here)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\n# Source BEACONs functions\nsource(file.path(dirpath,\"R/spatial.R\"))\nsource(file.path(dirpath,\"R/builder.R\"))\nsource(file.path(dirpath,\"R/utils.R\"))\n\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- here(\"builder\")\n\n# Set Builder output path (create the folder structure if missing)\nbuilder_dir &lt;- file.path(dirpath, \"output/Builder_output\")\nif (!dir.exists(builder_dir)) {\n  dir.create(builder_dir)\n}\n\n# Create the folder structure to receive output polygons\nout_dir &lt;- file.path(dirpath, \"output/shp_output\")\nif (!dir.exists(out_dir)) {\n  dir.create(out_dir, recursive = TRUE)\n}\n\n# Prefix given to identify unique conservation areas\ncolName &lt;- \"PB\"\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n\n# Use conservation areas as reserve seeds\ncatchments &lt;- st_read(file.path(dirpath,\"data/catchments_sample.shp\"))\n\nReading layer `catchments_sample' from data source \n  `E:\\MelinaStuff\\BEACONs\\git\\R_tools_public\\data\\catchments_sample.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 108 features and 15 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -2073549 ymin: 752749.6 xmax: -1946333 ymax: 861999.6\nProjected CRS: NAD_1983_Albers\n\nconservation_areas &lt;- st_read(file.path(dirpath,\"data/reserves_sample.shp\"))\n\nReading layer `reserves_sample' from data source \n  `E:\\MelinaStuff\\BEACONs\\git\\R_tools_public\\data\\reserves_sample.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -2063049 ymin: 815481.9 xmax: -1987393 ymax: 861999.6\nProjected CRS: NAD_1983_Albers\n\n# Run BUILDER\nnghbrs &lt;- neighbours(catchments)\nseed &lt;- seeds(catchments, areatarget_value = 100000000)\nbuilder(catchments_sf = catchments, data_source = \"catchment\", seeds = seed, neighbours = nghbrs, out_dir = builder_dir, builder_local_path = builder_path, catchment_level_intactness = 0.8, conservation_area_intactness = 1, output_upstream = TRUE, output_downstream = TRUE)\n\n# A tibble: 4 x 44\n  PB_94784 PB_95575 PB_95583 PB_95840 PB_95876 PB_95898 PB_95949 PB_96020\n     &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n1    94784    95575    95583    95840    95876    95898    95949    96020\n2    94837    95831    95831    95831    96075    95629    95840    95949\n3       NA       NA    95575       NA    97226       NA    95831    95840\n4       NA       NA       NA       NA       NA       NA       NA       NA\n# i 36 more variables: PB_96075 &lt;int&gt;, PB_97226 &lt;int&gt;, PB_97345 &lt;int&gt;,\n#   PB_97440 &lt;int&gt;, PB_97971 &lt;int&gt;, PB_98263 &lt;int&gt;, PB_98271 &lt;int&gt;,\n#   PB_98487 &lt;int&gt;, PB_98559 &lt;int&gt;, PB_98569 &lt;int&gt;, PB_98723 &lt;int&gt;,\n#   PB_98912 &lt;int&gt;, PB_98960 &lt;int&gt;, PB_99037 &lt;int&gt;, PB_99170 &lt;int&gt;,\n#   PB_99304 &lt;int&gt;, PB_99401 &lt;int&gt;, PB_99409 &lt;int&gt;, PB_99418 &lt;int&gt;,\n#   PB_99428 &lt;int&gt;, PB_99923 &lt;int&gt;, PB_99941 &lt;int&gt;, PB_100028 &lt;int&gt;,\n#   PB_100140 &lt;int&gt;, PB_100688 &lt;int&gt;, PB_100869 &lt;int&gt;, PB_100969 &lt;int&gt;, ...\n\n#############################################\n#  Generate potential conservation areas polygons\n#############################################\ntype &lt;- \"BENCHMARKS\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\nPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n#############################################\n#  Generate upstream polygons\n#############################################\ntype &lt;- \"UPSTREAM\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\nupPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n#############################################\n#  Generate downstream polygons\n#############################################\ntype &lt;- \"DOWNSTREAM\"\nout_tab &lt;- fetch_builder_output(builder_dir, type = type)\n\n# Convert builder output tables to polygons\ndownPBx_sf &lt;- dissolve_catchments_from_table(catchments_sf = catchments, \n                                             input_table = out_tab, \n                                             out_feature_id = colName)\n\n\n# Map example\n# Get the first conservation area ID\nfirst_pb_id &lt;- PBx_sf$PB[13]\n\n# Filter all layers for this conservation area\npb1      &lt;- PBx_sf[PBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Conservation Area\")\nup_pb1   &lt;- upPBx_sf[upPBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Upstream\")\ndown_pb1 &lt;- downPBx_sf[downPBx_sf$PB == first_pb_id, ] %&gt;% mutate(type = \"Downstream\")\n\n# Combine layers \noverlay_data &lt;- rbind(pb1, up_pb1, down_pb1)\n\n# Plot all layers together\nggplot() +\n  geom_sf(data = catchments, fill = NA, color = \"black\", size = 0.2) +\n  geom_sf(data = overlay_data, aes(fill = type), color = \"black\", alpha = 0.6) +\n  scale_fill_manual(\n    name = \"Type\",\n    values = c(\n      \"Conservation Area\" = \"tan\",\n      \"Upstream\" = \"green4\",\n      \"Downstream\" = \"steelblue1\"\n    )\n  ) +\n  labs(\n    title = paste(\"Conservation Area and Related Units:\", first_pb_id),\n    subtitle = \"Mapped with upstream and downstream polygons\",\n    x = NULL, y = NULL\n  ) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n\n\n\n\n\n\n\n# Save \nwrite_sf(PBx_sf, dsn =file.path(out_dir, \"CAs_poly.shp\"), append = FALSE)\nwrite_sf(upPBx_sf, dsn =file.path(out_dir, \"upstream_poly.shp\"), append = FALSE)\nwrite_sf(downPBx_sf, dsn =file.path(out_dir, \"downstream_poly.shp\"), append = FALSE)"
  },
  {
    "objectID": "methods.html",
    "href": "methods.html",
    "title": "Workflow",
    "section": "",
    "text": "clickable flowchart"
  },
  {
    "objectID": "methods.html#step-1",
    "href": "methods.html#step-1",
    "title": "Workflow",
    "section": "Step 1",
    "text": "Step 1"
  },
  {
    "objectID": "methods.html#step-2",
    "href": "methods.html#step-2",
    "title": "Workflow",
    "section": "Step 2",
    "text": "Step 2"
  },
  {
    "objectID": "methods.html#step-3",
    "href": "methods.html#step-3",
    "title": "Workflow",
    "section": "Step 3",
    "text": "Step 3"
  },
  {
    "objectID": "methods.html#step-4",
    "href": "methods.html#step-4",
    "title": "Workflow",
    "section": "Step 4",
    "text": "Step 4"
  },
  {
    "objectID": "methods.html#step-5",
    "href": "methods.html#step-5",
    "title": "Workflow",
    "section": "Step 5",
    "text": "Step 5"
  },
  {
    "objectID": "methods.html#step-6",
    "href": "methods.html#step-6",
    "title": "Workflow",
    "section": "Step 6",
    "text": "Step 6"
  },
  {
    "objectID": "methods.html#step-7",
    "href": "methods.html#step-7",
    "title": "Workflow",
    "section": "Step 7",
    "text": "Step 7"
  },
  {
    "objectID": "tools/builder.html#usage",
    "href": "tools/builder.html#usage",
    "title": "builder()",
    "section": "Usage",
    "text": "Usage\nbuilder(\n  catchments_sf, \n  data_source = \"catchment\",\n  seeds, \n  reserve_name,\n  neighbours, \n  out_dir = NULL,\n  builder_local_path, \n  catchment_level_intactness = 1, \n  conservation_area_intactness = 1, \n  area_target_proportion = 1, \n  area_type = \"land\", \n  construct_conservation_areas = TRUE,  \n  area_target_multiplier = 1,\n  handle_isolated_catchments = TRUE, \n  output_upstream = FALSE, \n  output_downstream = FALSE, \n  output_hydrology_metrics = FALSE,\n  area_land = \"Area_Land\", \n  area_water = \"Area_Water\",\n  skeluid = \"SKELUID\", \n  catchnum = \"CATCHNUM\", \n  subzone = \"FDA\", \n  zone = \"MDA\", \n  basin = \"BASIN\", \n  order1 = \"ORDER1\",\n  order2 = \"ORDER2\", \n  order3 = \"ORDER3\", \n  stream_length = \"STRMLEN\", \n  intactness = \"intact\", \n  isolated = \"Isolated\",\n  unique_identifier = \"PB\", \n  handler_summary = FALSE, \n  summary_intactness_props = '\"\"', \n  summary_area_target_props = '\"\"'\n)"
  },
  {
    "objectID": "tools/builder.html#arguments",
    "href": "tools/builder.html#arguments",
    "title": "builder()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with unique identifier column CATCHNUM.\ndata_source: Specify the seed type (catchment or reserve). Default is catchment.\nseeds: Seeds table from seeds() listing seed catchments and area targets.\nreserve_name: Reserve column listing the name of the reserve. Only used if data_source Reserve is selected.\nneighbours: Neighbours table from neighbours() listing all neighbouring pairs of catchments.\nout_dir: If provided, input (seeds, neighbours and catchments) files and output BUILDER tables will be saved to this directory. Otherwise a temp directory will be used. Function will attempt to create the directory if it doesn‚Äôt already exist.\nbuilder_local_path: Directory path to the benchmarkbuilder executable.\ncatchment_level_intactness: Minimum intactness value for catchment inclusion (between 0-1). i.e.¬†if value of 1 is used, only 100% intact catchments will be used. Default is 1.\nconservation_area_intactness: Minimum area-weighted intactness of final conservation areas. Only conservation areas meeting this value will be returned. Default is 1.\narea_target_proportion: The proportion of the Area target that conservation areas need to meet (0-1) to be returned by the function. Default is 1.\narea_type: If ‚Äòland‚Äô, only terrestrial areas are counted towards the area target. If ‚Äòwater‚Äô, only water areas are counter. If ‚Äòlandwater‚Äô, all areas are counted. Default is ‚Äòland‚Äô.\nconstruct_conservation_areas: Should builder build conservation areas? Default is TRUE.\narea_target_multiplier: Multiplier applied to the area target in the seed list that allows for adjustments to the area target without having to remake the seeds table. Default is 1.\nhandle_isolated_catchments: Should small isolated catchments be merged into the conservation areas? Default is TRUE.\noutput_upstream: Should upstream catchments be calculated? Default is FALSE.\noutput_downstream: Should downstream catchments be calculated? Default is FALSE.\noutput_hydrology_metrics: Should hydrology metrics be calculated? Default is FALSE.\narea_land: Catchments column listing the area of land in each catchment. Default is ‚ÄòArea_Land‚Äô.\narea_water: Catchments column listing the area of water in each catchment. Default is ‚ÄòArea_Water‚Äô.\nskeluid: Catchments column listing the skeluid field. Default is ‚ÄòSKELUID‚Äô\ncatchnum: Catchments column listing the unique catchments ID. Default is ‚ÄòCATCHNUM‚Äô\nsubzone: Catchments column listing the hydrological subzone. Default is ‚ÄòFDA‚Äô\nzone: Catchments column listing the hydrological zone. Default is ‚ÄòMDA‚Äô\nbasin: Catchments column listing the basin field. Default is ‚ÄòBASIN‚Äô\norder1: Catchments column listing the order 1 field. Default is ‚ÄòORDER1‚Äô\norder2: Catchments column listing the order 2 field. Default is ‚ÄòORDER2‚Äô\norder3: Catchments column listing the order 3 field. Default is ‚ÄòORDER3‚Äô\nstream_length: Catchments column listing stream length. Default is ‚ÄòSTRMLEN‚Äô\nintactness: Catchments column listing the intactness value. Default is ‚Äòintact‚Äô\nisolated: Catchments column identifying catchments isolated from the stream network. Default is ‚ÄòIsolated‚Äô\nunique_identifier: Prefix for conservation area names. Default is ‚ÄòPB‚Äô\nhandler_summary: Should a summary listing counts of available conservation areas at different intactness and area target proportions be created? Default is FALSE\nsummary_intactness_props: If a summary is created, provide the intactness proportions to be summarised in the format ‚Äò0.7,0.8,0.9‚Äô.\nsummary_area_target_props: If a summary is created, provide the area target proportions to be summarised in the format ‚Äò0.7,0.8,0.9‚Äô."
  },
  {
    "objectID": "tools/builder.html#output",
    "href": "tools/builder.html#output",
    "title": "builder()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble with column names representing conservation areas, and rows of catchments making up the conservation areas. If output_dir is provided, additional BUILDER output tables (e.g., hydrology, summary metrics) are saved. If an out_dir is specified, the returned tibble corresponds to the output file named *_COLUMN_All_Unique_BAs.csv generated for the specific run."
  },
  {
    "objectID": "tools/builder.html#examples",
    "href": "tools/builder.html#examples",
    "title": "builder()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n** Prior to run the example, the benchmarkbuilder executable needs to be acquired by contacting the BEACONs Project.\n\nDownload and unzip BEACONs R Tools\nRun BUILDER\n\nThe main parameters to adjust when building conservation areas are: - data_source: Is the provided seed list catchment or reserve? - Area target: Set in the seeds table, this defines the minimum size for each conservation area. - Catchment-level intactness: Only catchments with intactness values greater than this value will be added to the conservation area. - Conservation area intactness: Only conservation areas with an area-weighted intactness greater than or equal to this value will be returned. - Area-target proportion: The proportion of the Area target that conservation areas need to meet. Allows output of conservation areas smaller than the area target (e.g.¬†if no conservation areas meet 100% of the area target, area target multiplier can be lowered to 0.9 to search for smaller conservation areas).\n\nRunning ‚Äòbuilder()‚Äô using catchments seed type.\n\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\n\n########################\n##    PARAMS   \n########################\n# Folder path to unzipped BEACONs_R_Tools folder\ndirpath &lt;- \"path/to/BEACONs_R_tools\"\n\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- \"path/to/builderexecutable/folder\"\n\nsetwd(dirpath)\n\n########################\n##    RUN   \n########################\nsource(\"./R/builder.R\")\nsource(\"./R/utils\")\n\n# Create the folder structure\nif (!dir.exists(file.path(dirpath, \"Builder_output\"))) {\n  dir.create(file.path(dirpath, \"Builder_output\"))\n}\n\n# Use all catchments as seeds with a single area target\ncatchments &lt;- st_read(\"./data/catchments_sample.shp\")\n\nnghbrs &lt;- neighbours(catchments)\nseed &lt;- seeds(catchments_sf = catchments, areatarget_value = 1000000000)\nbuilder(catchments_sf = catchments, seeds = seed, neighbours = nghbrs, out_dir = file.path(dest_folder, \"Builder_output\"), builder_local_path = builder_path)\n\nRunning ‚Äòbuilder()‚Äô using reserves seed type.\n\n# Load required libraries\nlibrary(sf)\nlibrary(dplyr)\nlibrary(tidyr)\n\n########################\n##    PARAMS   \n########################\n# Folder path to the benchmarkbuilder executable\nbuilder_path &lt;- \"path/to/builderexecutable/folder\"\n\n# Folder path to unzipped BEACONs_R_Tools folder\ndirpath &lt;- \"path/to/BEACONs_R_tools\"\n\nsetwd(dirpath)\n\n########################\n##    RUN   \n########################\nsource(\"./R/builder.R\")\nsource(\"./R/utils\")\n\n# Create the folder structure\nif (!dir.exists(file.path(dest_folder, \"Builder_output\"))) {\n  dir.create(file.path(dest_folder, \"Builder_output\"))\n}\n\n# Use conservation areas as reserve seeds\ncatchments &lt;- st_read(\"./data/catchments_sample.shp\")\nconservation_areas &lt;- st_read(\"./data/reserves_sample.shp\")\n\nnghbrs &lt;- neighbours(catchments)\nreserve_seed &lt;- reserve_seeds(catchments, CAs_sf=conservation_areas, CAs_id = \"reserve\", areatarget_value = 10000, joinType = \"INTERSECT\")\nbuilder(catchments_sf = catchments, data_source = \"Reserve\", seeds = reserve_seed, reserve_name = \"reserve\", neighbours = nghbrs, out_dir = file.path(dest_folder, \"Builder_output\"), builder_local_path = builder_path, catchment_level_intactness = 0.8, conservation_area_intactness = 0.8)"
  },
  {
    "objectID": "tools/dci.html#usage",
    "href": "tools/dci.html#usage",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Usage",
    "text": "Usage\ncalc_dci(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)\n\ncalc_lwdci(\n  conservation_area_sf,\n  stream_sf = NULL,\n  col_name = \"network\",\n  buffer_width = 0.1\n)"
  },
  {
    "objectID": "tools/dci.html#arguments",
    "href": "tools/dci.html#arguments",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Arguments",
    "text": "Arguments\nBoth functions need the following:\n\nCAs_sf: sf object of conservation areas in which to calculate DCI.\nstream_sf: sf object of river network. Must have streams grouped in a BASIN attribute.\nCAs_id: Column in CAs_sf specify unique identifier. Default is network.\nbuffer_width: (Optional) Width of buffer to apply to stream segments. Defaults to 0.1. Used to ensure adjacent stream segments are connected during analysis."
  },
  {
    "objectID": "tools/dci.html#output",
    "href": "tools/dci.html#output",
    "title": "calc_dci() and calc_lwdci()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA vector of numeric DCI or lwDCI values matching the input features."
  },
  {
    "objectID": "tools/dci.html#details",
    "href": "tools/dci.html#details",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Details",
    "text": "Details\nDeveloped by Cote et al.¬†(2009), the Dendritic Connectivity Index quantifies ‚Äúlongitudinal connectivity of river networks based on the expected probability of an organism being able to move freely between two random points of the network.‚Äù Longitudinal connectivity refers to connections between upstream and downstream sections of the network. The index is calculated as\n\n\n\nwhere li is the length of a stream (or river) section and L is the total length of the stream network within the benchmark. The index ranges from 0 (low longitudinal connectivity) to 1 (high longitudinal connectivity).\nIf the conservation areas overlap two ocean drainage, the use of calc_lwdci() is more suitable."
  },
  {
    "objectID": "tools/dci.html#examples",
    "href": "tools/dci.html#examples",
    "title": "calc_dci() and calc_lwdci()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\nThe example below allow to estimate dci and lwdci for a set of conservation areas. Because the two functions returns a vector of index, the script calculate the respective indexes and integrate the results in the reserves object prior to save it as a new shapefile.\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n# Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# Set working directory\nsetwd(\"your/path/to/downloads/folder\")\n\nsource(\"./R/hydrology.R\")\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\ndirpath &lt;- getwd()\n\n#Set access path \nreserves &lt;- file.path(dirpath, \"data/reserves_sample.shp\")\nstreams &lt;- file.path(dirpath, \"data/streams_sample.shp\")\n\ncolName &lt;- \"reserve\"\n\n#Create output folder\nout_dir &lt;- file.path(dirpath, \"shp_output\")\nif(!dir.exists(out_dir)){\n  dir.create(out_dir)\n}\n\n# Set if DCI and LWDCI should be added\naddDCI &lt;- TRUE\naddLWDCI &lt;- TRUE\n\n\n\n# --------------------------------------\n#--RUN\n# --------------------------------------\n# Initialize sf objects\nreserves_sf &lt;- st_read(reserves)\nstreams_sf &lt;- st_read(streams)\n\nif(addDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(dci = sapply(1:nrow(reserves_sf), function(i) {\n    i &lt;- reserves_sf[i, ]\n    calc_dci(i, streams_sf, CAs_id = colName) \n  }))\n}\nif(addLWDCI){\n  reserves_sf &lt;- reserves_sf %&gt;%\n  mutate(lwdci = sapply(1:nrow(reserves_sf), function(j) {\n    j &lt;- reserves_sf[j, ]\n    calc_lwdci(j, streams_sf, CAs_id = colName) \n  }))\n}\n\n#Save results\nwrite_sf(reserves_sf, dsn=file.path(out_dir, \"reserves_dci.shp\"), append = FALSE)"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#usage",
    "href": "tools/evaluate_criteria_using_clip.html#usage",
    "title": "evaluate_criteria_using_clip()",
    "section": "Usage",
    "text": "Usage\nevaluate_criteria_using_clip(\n  conservation_area_sf, \n  criteria_raster, \n  conservation_area_id = NULL, \n  class_values = c(), \n  target_size = NULL\n)"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#arguments",
    "href": "tools/evaluate_criteria_using_clip.html#arguments",
    "title": "evaluate_criteria_using_clip()",
    "section": "Arguments",
    "text": "Arguments\n\nCAs_sf: sf object of conservation areas.\ncriteria_raster: Raster object of the representation layer classified into categorical classes\nCAs_id: Column in CAs_sf specify unique identifier.\nclass_values: A vector of classes in representation_raster to generate targets for. Defaults to all classes in the representation_raster.\ntarget_size: The area in km2 that targets will sum to. Default is NULL"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#output",
    "href": "tools/evaluate_criteria_using_clip.html#output",
    "title": "evaluate_criteria_using_clip()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble with columns: - conservation_area_id (if provided) - class_value: the list of class_values} - area_km2: the area of each class_value in the CAs_sf} - class_proportion: area_km2/sum(area_km2)} - target_km2"
  },
  {
    "objectID": "tools/evaluate_criteria_using_clip.html#examples",
    "href": "tools/evaluate_criteria_using_clip.html#examples",
    "title": "evaluate_criteria_using_clip()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nRun the examples below.\n\n\n# Load libraries\nlibrary(sf)\nlibrary(terra)\nlibrary(dplyr)\nlibrary(here)\n\n# --------------------------------------\n# SET PARAMS  --------------------\n# --------------------------------------\n# Set working directory\ndirpath &lt;- here(\".\")\n\nsetwd(dirpath)\nsource(\"./R/representation.R\")\n\n#Set access path \nreserves_sf &lt;- st_read(file.path(dirpath, \"data/reserves_sample.shp\"), quiet = TRUE)\nnalc &lt;- rast(file.path(dirpath, \"data/nalc_sample.tif\"))\n\nresult &lt;- evaluate_criteria_using_clip(reserves_sf, nalc, conservation_area_id = \"reserve\")\n\n# ‚îÄ‚îÄ To display landcover classes proportion per conservation areas ------------\nlibrary(readr)\nlibrary(ggplot2)\n\n# Read landcover color palette from files\nlandcover_colors &lt;- read_csv(file.path(dirpath, \"data/lc_cols.csv\"))\n\n# Join hex code to results\nresults &lt;- result %&gt;%\n  mutate(class_value = as.integer(class_value)) %&gt;%\n  left_join(landcover_colors, by = \"class_value\")\n\n# set number of piechart based on number of conservation areas.\nn_chart &lt;- length(unique(reserves_sf$reserve))\n\n# Plot proportion\nggplot(results,\n       aes(x = \"\", y = class_proportion, fill = label)) +  # use label for legend\n  geom_col(width = 1, colour = \"white\") +\n  coord_polar(theta = \"y\") +\n  facet_wrap(~ reserve) +\n  scale_fill_manual(values = setNames(results$hex, results$label)) +\n  labs(title = \"Pie charts of landcover class proportions by conservation area\") +\n  theme_void() +\n  theme(strip.text = element_text(size = 12, face = \"bold\"),\n        plot.title = element_text(hjust = 0.5, margin = margin(b = 10))\n        )"
  },
  {
    "objectID": "tools/index_Builder.html",
    "href": "tools/index_Builder.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BUILDER is a user friendly software application, developed in C# .NET framework, to assist conservation planners with the design of ecological benchmarks. This package provides a set of R functions to call BUILDER and fetch the main output table. The partner package beaconstools provides functions to process and analyse output tables from BUILDER in R.\nBUILDER explicitly incorporates hydrologic connectivity for the integration of aquatic and terrestrial conservation planning in protected areas design. BUILDER constructs ecological benchmarks using a deterministic construction algorithm that aggregates catchments to a user defined size and intactness. For the purpose of this demo, we will refer to the conservation areas created by BUILDER as benchmarks, however BUILDER can also be used to design conservation areas not intended to serve as benchmarks.\nBUILDER constructs ecological benchmarks based on three principal criteria:\n\nIntactness, a measure of the absence of human industrial activity and a proxy for the intactness of biological and physical processes\nHydrologic connectivity of intact water catchments, as a measure of the integrity of aquatic systems\nSize, as a measure of the resilience of the system to disturbance"
  },
  {
    "objectID": "tools/index_Builder.html#beacons-builder",
    "href": "tools/index_Builder.html#beacons-builder",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BUILDER is a user friendly software application, developed in C# .NET framework, to assist conservation planners with the design of ecological benchmarks. This package provides a set of R functions to call BUILDER and fetch the main output table. The partner package beaconstools provides functions to process and analyse output tables from BUILDER in R.\nBUILDER explicitly incorporates hydrologic connectivity for the integration of aquatic and terrestrial conservation planning in protected areas design. BUILDER constructs ecological benchmarks using a deterministic construction algorithm that aggregates catchments to a user defined size and intactness. For the purpose of this demo, we will refer to the conservation areas created by BUILDER as benchmarks, however BUILDER can also be used to design conservation areas not intended to serve as benchmarks.\nBUILDER constructs ecological benchmarks based on three principal criteria:\n\nIntactness, a measure of the absence of human industrial activity and a proxy for the intactness of biological and physical processes\nHydrologic connectivity of intact water catchments, as a measure of the integrity of aquatic systems\nSize, as a measure of the resilience of the system to disturbance"
  },
  {
    "objectID": "tools/index_Builder.html#catchments",
    "href": "tools/index_Builder.html#catchments",
    "title": "BEACONs R Tools",
    "section": "Catchments",
    "text": "Catchments\nThe building blocks for BUILDER is a set of catchments with associated flow directions for the underlying stream network. This allows BUILDER to identify upstream and downstream catchments for any given location. Should we provide a brief description of the catchments dataset and how to download them?"
  },
  {
    "objectID": "tools/index_Builder.html#aggregation-algorithm",
    "href": "tools/index_Builder.html#aggregation-algorithm",
    "title": "BEACONs R Tools",
    "section": "Aggregation algorithm",
    "text": "Aggregation algorithm\nBUILDER ‚Äògrows‚Äô ecological benchmarks using a deterministic construction algorithm that aggregates catchments. This process enables intactness, size and hydrologic criteria to be incorporated into benchmark design.\nThe starting catchments for building benchmarks are called seeds. These can be selected using size and intactness criteria e.g., all catchments that are 100% intact and greater than 500km2. Starting from a seed, BUILDER grows a benchmark by aggregating neighbouring catchments that exceed the user defined catchment-level intactness threshold. As catchments are added, growth is prioritized in the upstream direction. This emphasizes inclusion of headwaters within benchmarks, and encourages the formation of benchmarks along stream networks. Further, by adding all eligible upstream catchments before re-querying for more, benchmarks are grown with a more compact shape. If re-querying were to occur after adding each upstream catchment, benchmarks would tend to grow along single streams, resulting in linear configurations. To further compact the shape of the benchmark, BUILDER prioritizes the addition of catchments within hydrological zones (i.e.¬†Fundamental Drainage Areas, FDAs) associated with the benchmark before adding catchments in a neighbouring FDA.\nOnce all available upstream catchments are added, BUILDER grows downstream. Downstream growth adds all neighbouring catchments downstream of the catchment aggregation then re-queries for upstream catchments. Benchmarks are grown until:\n\nThere are no more neighbouring, intact catchments to add, or\nThe benchmarks area exceeds the user-specified Area Target.\n\nIf the latter occurs, and the area-weighted intactness of the benchmark exceeds the benchmark-level intactness threshold, then the benchmark is included in the output."
  },
  {
    "objectID": "tools/index_Builder.html#builder-r-functions",
    "href": "tools/index_Builder.html#builder-r-functions",
    "title": "BEACONs R Tools",
    "section": "BUILDER R Functions",
    "text": "BUILDER R Functions\nBEACONs BUILDER has 5 main functions:\n\nseeds\nreserve_seeds\nneighbours\nbuilder\nfetch_builder_output\n\n\nseeds\nThe function seeds() creates a seeds table, which is an input to builder().\nIt identifies seed catchments and assigns them an area target.\n\n\nreserve_seeds\nThe function reserve_seeds() creates a seeds table based on conservation areas, which is an input to builder().\nIt identifies seed catchments inside a conservation area and assigns them an area target.\n\n\nneighbours\nThe function neighbours() creates a table listing pairwise catchment neighbours. Used as an input to builder().\n\n\nbuilder\nThe function builder() prepares the input files and parameters and passes them to a command line version of BUILDER executable software. The function then fetches and returns the main BUILDER output table into the R environment.\n\n\nfetch_builder_output\nThe function fetch_builder_output() loads pre-processed builder() output table into the R environment. It reads the appropriate table based on the specified type and makes it available for subsequent analyses (e.g., polygon creation)."
  },
  {
    "objectID": "tools/index_Builder.html#process",
    "href": "tools/index_Builder.html#process",
    "title": "BEACONs R Tools",
    "section": "üèóÔ∏è Process",
    "text": "üèóÔ∏è Process\n\nPrepares input tables: neighbours, either seeds or reserve_seeds, and catchments.\nMake sure default parameters are relevant and Set BUILDER parameters such as catchment_level_intactness, conservation_area_intactness.\nbuilder() returns the *_COLUMN_All_Unique_BAs.csv file listing conservation areas and their catchments by default.\nTo access output tables containing upstream or downstream attributes, use the fetch_builder_output function.\nSubsequent processing, such as creating polygons of benchmarks using builder() output and assessing ecological attributes is done using others BEACONs functions (see examples in section Articles)."
  },
  {
    "objectID": "tools/index_Builder.html#key-parameters",
    "href": "tools/index_Builder.html#key-parameters",
    "title": "BEACONs R Tools",
    "section": "üîß Key Parameters",
    "text": "üîß Key Parameters\n\n\n\n\n\n\n\nParameter\nDescription\n\n\n\n\nArea target\nSet in the seeds table; minimum size (m¬≤) for each conservation area.\n\n\nCatchment intactness\nMinimum intactness required for catchments to be included.\n\n\nConservation area intactness\nMinimum area-weighted intactness for a conservation area to be returned.\n\n\nArea target proportion\nAllows output of smaller areas (e.g., 0.9 returns areas &gt;= 90% of the area target)."
  },
  {
    "objectID": "tools/index_Builder.html#tip",
    "href": "tools/index_Builder.html#tip",
    "title": "BEACONs R Tools",
    "section": "üí° Tip",
    "text": "üí° Tip\nUse output_dir to preserve BUILDER‚Äôs complete outputs when running multiple builds. These files can be further analyzed using others BEACONs functions."
  },
  {
    "objectID": "tools/index_Builder.html#citation",
    "href": "tools/index_Builder.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/index_Representation.html",
    "href": "tools/index_Representation.html",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a variety of functions for two types of representation analysis:\nThe calc_dissimilarity() function compares the distributions of a raster layer between a conservation area and a broader study region that we are trying to represent. The closer the distributions of raster values, the lower the dissimilarity score. Values of 0.2 or less are considered ‚Äògood‚Äô representation.\nAnother approach focus on reaching target-based target using proportional representation. The latter ensure specific target areas of different representation classes are met in one or multiple conservation areas.\nRepresentation analyses typically include multiple layers assumed to represent a range of ecological processes. They often include climate layers, productivity, riparian zones etc. The goal of the representation analysis is to identify conservation areas that adequately capture the target amounts of representation classes (in our case NALC classes) deemed to be proportionally representative of the study region. Usually the target amounts should be met in full in a conservation area, rather than being split between multiple conservation areas. The idea being that the conservation area should provide a sufficient area for the ecological processes associated with specific target classes to operate. In a network of multiple conservation areas, different target classes and different ecological processes may therefore be represented by different conservation areas.\nThe xx main representation functions are:\n\ncalc_dissimilarity\nevaluate_criteria_using_clip\n\n\n\nThe function calc_dissimilarity() calculate dissimilarity values between a set of polygons and a reference area..\n\n\n\nThe function evaluate_criteria_using_clip() clips the criteria raster to the conservation area and calculates the proportion of each class within it."
  },
  {
    "objectID": "tools/index_Representation.html#beacons-representation-r-functions",
    "href": "tools/index_Representation.html#beacons-representation-r-functions",
    "title": "BEACONs R Tools",
    "section": "",
    "text": "BEACONs developped a variety of functions for two types of representation analysis:\nThe calc_dissimilarity() function compares the distributions of a raster layer between a conservation area and a broader study region that we are trying to represent. The closer the distributions of raster values, the lower the dissimilarity score. Values of 0.2 or less are considered ‚Äògood‚Äô representation.\nAnother approach focus on reaching target-based target using proportional representation. The latter ensure specific target areas of different representation classes are met in one or multiple conservation areas.\nRepresentation analyses typically include multiple layers assumed to represent a range of ecological processes. They often include climate layers, productivity, riparian zones etc. The goal of the representation analysis is to identify conservation areas that adequately capture the target amounts of representation classes (in our case NALC classes) deemed to be proportionally representative of the study region. Usually the target amounts should be met in full in a conservation area, rather than being split between multiple conservation areas. The idea being that the conservation area should provide a sufficient area for the ecological processes associated with specific target classes to operate. In a network of multiple conservation areas, different target classes and different ecological processes may therefore be represented by different conservation areas.\nThe xx main representation functions are:\n\ncalc_dissimilarity\nevaluate_criteria_using_clip\n\n\n\nThe function calc_dissimilarity() calculate dissimilarity values between a set of polygons and a reference area..\n\n\n\nThe function evaluate_criteria_using_clip() clips the criteria raster to the conservation area and calculates the proportion of each class within it."
  },
  {
    "objectID": "tools/index_Representation.html#citation",
    "href": "tools/index_Representation.html#citation",
    "title": "BEACONs R Tools",
    "section": "Citation",
    "text": "Citation\nHoule M, Vernier P, Lisgo K, Edwards M, Schmiegelow F (2025). BEACONs R_Tools_Public: Building conservation areas in R. Available at https://beaconsproject.github.io/R_tools_public/."
  },
  {
    "objectID": "tools/neighbours.html#usage",
    "href": "tools/neighbours.html#usage",
    "title": "neighbours()",
    "section": "Usage",
    "text": "Usage\nneighbours(\n  catchments_sf\n)"
  },
  {
    "objectID": "tools/neighbours.html#arguments",
    "href": "tools/neighbours.html#arguments",
    "title": "neighbours()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM."
  },
  {
    "objectID": "tools/neighbours.html#output",
    "href": "tools/neighbours.html#output",
    "title": "neighbours()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of neighbouring pairs with columns CATCHNUM and neighbours."
  },
  {
    "objectID": "tools/neighbours.html#examples",
    "href": "tools/neighbours.html#examples",
    "title": "neighbours()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nneighbours(catchments_sf = catchments_sample)\n\n# save neighbours as csv\nneighbour &lt;- neighbours(catchments_sf = catchments_sample)\nwrite.csv(neighbour, file=file.path(dirpath,\"Builder_input/neighbours.csv\"), row.names=FALSE)"
  },
  {
    "objectID": "tools/seeds.html#usage",
    "href": "tools/seeds.html#usage",
    "title": "seeds()",
    "section": "Usage",
    "text": "Usage\nseeds(\n  catchments_sf,\n  filter_polygon = NULL,\n  areatarget_value = NULL,\n  areatarget_col = NULL,\n  areatarget_polygon = NULL,\n  areatarget_polygon_col = NULL\n)"
  },
  {
    "objectID": "tools/seeds.html#arguments",
    "href": "tools/seeds.html#arguments",
    "title": "seeds()",
    "section": "Arguments",
    "text": "Arguments\n\ncatchments_sf: sf object of the catchments dataset with a unique identifier column: CATCHNUM.\nfilter_polygon: (Optional) sf polygon to filter catchments. Only catchments inside the polygon are kept.\nareatarget_value: (Optional) Single area target value (in m¬≤) to apply to all seeds.\nareatarget_col: (Optional) Column in catchments_sf containing individual area targets.\nareatarget_polygon: (Optional) sf polygon object holding area target values, used via spatial join.\nareatarget_polygon_col: (Optional) Column in areatarget_polygon containing area target values."
  },
  {
    "objectID": "tools/seeds.html#output",
    "href": "tools/seeds.html#output",
    "title": "seeds()",
    "section": "üì§ Output",
    "text": "üì§ Output\nA tibble of seed catchments and their assigned area targets."
  },
  {
    "objectID": "tools/seeds.html#details",
    "href": "tools/seeds.html#details",
    "title": "seeds()",
    "section": "Details",
    "text": "Details\n\nFiltering\nIf no filter is provided, all catchments in catchments_sf will be added to the seeds table.\n\nTo filter using a column, use dplyr::filter() before passing catchments_sf to seeds().\nIf filter_polygon is used, filtering is based on whether the centroid (using sf::st_point_on_surface()) falls inside the polygon.\n\n\n\nArea Targets\nArea targets must be in square meters (m¬≤). Provide one of the following (priority is top to bottom):\n\nSingle value: areatarget_value applies to all seeds.\nColumn-based: Values from areatarget_col in catchments_sf.\nSpatial join: Join with areatarget_polygon; values from areatarget_polygon_col.¬†When multiple polygons overlap a catchment, the value with the most overlap is used."
  },
  {
    "objectID": "tools/seeds.html#examples",
    "href": "tools/seeds.html#examples",
    "title": "seeds()",
    "section": "Examples",
    "text": "Examples\n\nRunning the examples\n\nDownload and unzip BEACONs R Tools\nCreate the folder structure\n\n# Set working directory\nsetwd(\"your/path/to/downloads\")\n\ndirpath &lt;- getwd()\n\n# Create the folder structure\ntreedir &lt;- c(\"R\",\"data\",\"Builder_input\")\nfor(d in treedir){\n  if (!dir.exists(file.path(dirpath, d))) {\n    dir.create(file.path(dirpath, d), recursive = TRUE)\n  }\n}\n\nRun the examples below.\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(utils)\n\nsource(\"./R/builder.R\")\n\n# Use all catchments as seeds with a single area target\ncatchments_sample &lt;- readRDS(\"data/catchments_sample.rds\")\nseeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\n\n# Use column-based area targets\ncatchments_sample$area_target &lt;- 1000000000\nseeds(catchments_sf = catchments_sample, areatarget_col = \"area_target\")\n\n# Filter based on a column value\ncatchments_sample %&gt;%\n  filter(intact == 1) %&gt;%\n  seeds(catchments_sf = ., areatarget_value = 1000000000)\n\n# Filter using a spatial polygon\nref_poly &lt;- data.frame(\n  lon = c(-138.4, -138.1, -138.1, -138.4, -138.1, -138.1, -138, -138),\n  lat = c(64.3, 64.3, 64.1, 64.1, 64.3, 64.1, 64.1, 64.3),\n  Areatarget = c(rep(1000000000, 4), rep(2000000000, 4))\n) %&gt;%\n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) %&gt;%\n  group_by(Areatarget) %&gt;%\n  summarise(geometry = st_combine(geometry)) %&gt;%\n  st_cast(\"POLYGON\") %&gt;%\n  st_transform(st_crs(catchments_sample))\n\nseeds(\n  catchments_sf = catchments_sample,\n  filter_polygon = ref_poly,\n  areatarget_polygon = ref_poly,\n  areatarget_polygon_col = \"Areatarget\"\n)\n\n# save seeds as csv\nseed &lt;- seeds(catchments_sf = catchments_sample, areatarget_value = 1000000000)\nwrite.csv(seed, file=file.path(dirpath,\"Builder_input/seeds.csv\"), row.names=FALSE)"
  }
]